import com.ember.peek.SimulatedNetwork;

source("util.bsh");

if (runArgument.runUsingMultihop ) {
  std.print("****TODO: Fix for multi-hop and host****");
  return;
}

SimulatedNetwork network = createNetwork();
String[] devices = {"ed0", "mn1", "coord2"};
String[] socImages;
String ncpImage;
if (shouldSkipEccTest()) {
  socImages = new String[] {
    "build/af-test-apps/SeIpd-simulation/SeIpd",
    "build/af-test-apps/MnEsiIpd-simulation/MnEsiIpd",
    "build/af-test-apps/SeEsp-simulation/SeEsp",
  };
  ncpImage = "app/ncp/sample-app/mn-ncp-spi/simulation/build/exe/mn-ncp-spi";
} else {
  socImages = new String[] {
    "build/af-test-apps/SeIpd-simulation-REAL_ECC/SeIpd",
    "build/af-test-apps/MnEsiIpd-simulation-REAL_ECC/MnEsiIpd",
    "build/af-test-apps/SeEsp-simulation-REAL_ECC/SeEsp",
  };
  ncpImage = "app/ncp/sample-app/mn-ncp-spi-real_ecc/simulation/build/exe/mn-ncp-spi";
}
String[] hostImages = new String[] {
  "build/af-test-apps/SeIpd-simulation-ezsp/SeIpd",
  "build/af-test-apps/MnEsiIpd-simulation-ezsp/MnEsiIpd",
  "build/af-test-apps/SeEsp-simulation-ezsp/SeEsp",
};

// Create network and load devices according to the runArguments provided.
addAndLoadDevices(devices, socImages, hostImages, ncpImage);
setupEncryption();

// Debug print is compiled in but disabled by default in the multi-network
// application.
debugprintOn("mn1", "Debug");

// The status of the multi-network library is not yet in the "libs" output.
//expect("mn1", "libs", "Multi-network library present");

// Check that the end device and coordinator have one network and that the
// multi-network node has two.
send("ed0", "info");
expect("ed0",
       ("Nwk cnt: 1.*"
        + "nwk 0 \\[Primary \\(pro\\)\\].*"
        + "  nodeType \\[0x03\\]"),
       timeout,
       true);
send("mn1", "info");
expect("mn1",
       ("Nwk cnt: 2.*"
        + "nwk 0 \\[Coordinator \\(pro\\)\\].*"
        + "  nodeType \\[0x01\\].*"
        + "nwk 1 \\[SleepyEndDevice \\(pro\\)\\].*"
        + "  nodeType \\[0x04\\]"),
       timeout,
       true);
send("coord2", "info");
expect("coord2",
       ("Nwk cnt: 1.*"
        + "nwk 0 \\[Primary \\(pro\\)\\].*"
        + "  nodeType \\[0x01\\]"),
       timeout,
       true);

// Set up the coordinator-side of the multi-network device.
send("mn1", "network set 0");
networkFindUnused("mn1", 5000, true);
expect("mn1", ".*Registration complete");
expect("mn1", "network pjoin 0xFF", "pJoin for 255 sec: 0x00");
networkFindJoinable("ed0", 2000, true);
expect("ed0", "Registration complete", 90000);
// Reboot does not work in simulation on the host because the NCP does not
// actually reset.
if (!runArgument.runUsingHostApps) {
  reboot("ed0");
  expect("ed0", "Registration complete", 30000);
}
assert(nodeId("mn1").equals("0x0000"));
String ed0 = findNodeByName("ed0").nodeIdHex;

// Set up the end device-side of the multi-network device.
expect("coord2", "network form 20 0 0xBBBB", ".*EMBER_NETWORK_UP.*");
findNodeByName("coord2").nodeIdHex = "0000";

expect("coord2", ".*Registration complete");
expect("coord2", "network pjoin 0xFF", "pJoin for 255 sec: 0x00");
send("mn1", "network set 1");
send("mn1", "network find joinable");
String mn1 = expect("coord2", ".*New node joined, shortID=0x[0-9a-fA-F]{4}", 2000);
mn1 = mn1.substring(mn1.indexOf("shortID=") + 8);
assert(!mn1.equals("0x0000"));
// Depending on how the test is configured to run, this message sometimes comes
// before the one we just waited for on coord2, so just don't bother with this
// one.  If the node doesn't come up, the "Registration complete" will never
// happen and we'll die there.
//expect("mn1", ".*EMBER_NETWORK_UP");
expect("mn1", "Registration complete", 60000);

// Verify that the "info" command returns appropriate information for each
// network on the multi-network device.
String ed0Channel = channel("ed0");
String ed0ExtendedPanId = extendedPanId("ed0");
String ed0PanId = panId("ed0");
send("mn1", "network set 0");
expectMultiline("mn1",
                "info",
                new String[] {
                  "node \\[\\(>\\)" + eui64("mn1") + "\\] chan \\[" + ed0Channel + "\\] pwr \\[3\\]",
                  "panID \\[" + ed0PanId + "\\] nodeID \\[0x0000\\] xpan \\[0x\\(>\\)" + ed0ExtendedPanId + "\\]",
                  "nodeType \\[0x01\\]",
                });
networkWait(1000);
String coord2Channel = channel("coord2");
String coord2ExtendedPanId = extendedPanId("coord2");
String coord2PanId = panId("coord2");
send("mn1", "network set 1");
expectMultiline("mn1",
                "info",
                new String[] {
                  "node \\[\\(>\\)" + eui64("mn1") + "\\] chan \\[" + coord2Channel + "\\] pwr \\[3\\]",
                  "panID \\[" + coord2PanId + "\\] nodeID \\[" + mn1 + "\\] xpan \\[0x\\(>\\)" + coord2ExtendedPanId + "\\]",
                  "nodeType \\[0x04\\]",
                });
networkWait(1000);

// The single-network end device should not have any bindings.
expect("ed0", "option binding-table print", "0 of \\d+ bindings used");
assert(network.expect("ed0", port, null, "[0-9a-fA-F]{2}:.*", timeout, true) == null);

// The multi-network coordinator should have bindings to from its first network
// and first endpoint to the single-network end device.  It should not have any
// from its second network or second endpoint.
checkBindingTable("mn1", 
                  new String[] {
                    ".*: UNICA  0    0x01  0x01  0x0700 0x.... \\(>\\)" + eui64("ed0"),
                    ".*: UNICA  0    0x01  0x01  0x0701 0x.... \\(>\\)" + eui64("ed0"),
                    ".*: UNICA  0    0x01  0x01  0x0702 0x.... \\(>\\)" + eui64("ed0"),
                    ".*: UNICA  0    0x01  0x01  0x0703 0x.... \\(>\\)" + eui64("ed0"),
                });
  
// The single-network coordinator should have bindings to the second endpoint
// of the multi-network end device.
checkBindingTable("coord2",
                  new String[] {
                    ".*: UNICA  0    0x01  0x02  0x0700 0x.... \\(>\\)" + eui64("mn1"),
                    ".*: UNICA  0    0x01  0x02  0x0701 0x.... \\(>\\)" + eui64("mn1"),
                    ".*: UNICA  0    0x01  0x02  0x0702 0x.... \\(>\\)" + eui64("mn1"),
                    ".*: UNICA  0    0x01  0x02  0x0703 0x.... \\(>\\)" + eui64("mn1"),
                });


// Set the CLI to the end device network and try sending read attributes on the
// coordinator network.  This should work because the framework will switch the
// network based on the source endpoint.
send("mn1", "network set 1");
send("mn1", "zcl global read 0x0000 0x0000");
send("mn1", "send " + ed0 + " 0x01 0x01");
expect("mn1", "T[0-9a-fA-F]{8}:TX \\(CLI\\) Ucast 0x00");
expectMultiline("ed0",
                new String[] {
                  "T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x0000 \\(Basic\\) FC 00 seq [0-9a-fA-F]{2} cmd 00 payload\\[00 00 \\]",
                  "T[0-9a-fA-F]{8}:TX \\(resp\\) Ucast 0x00",
                });
expectMultiline("mn1",
                new String[] {
                  "T[0-9a-fA-F]{8}:RX len 8, ep 01, clus 0x0000 \\(Basic\\) FC 08 seq [0-9a-fA-F]{2} cmd 01 payload\\[00 00 00 20 03 \\]",
                  "T[0-9a-fA-F]{8}:TX \\(resp\\) Ucast 0x00",
                });
expect("ed0", "T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x0000 \\(Basic\\) FC 00 seq [0-9a-fA-F]{2} cmd 0B payload\\[01 00 \\]");
networkWait(1000);
send("ed0", "zcl global read 0x0000 0x0000");
send("ed0", "send 0x0000 0x01 0x01");
expect("ed0", ".*T[0-9a-fA-F]{8}:TX \\(CLI\\) Ucast 0x00");
expect("mn1", ".*T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x0000 \\(Basic\\) FC 00 seq [0-9a-fA-F]{2} cmd 00 payload\\[00 00 \\]");
expect("mn1", ".*T[0-9a-fA-F]{8}:TX \\(resp\\) Ucast 0x00");
expectMultiline("ed0", 
                new String[] {
                "T[0-9a-fA-F]{8}:RX len 8, ep 01, clus 0x0000 \\(Basic\\) FC 08 seq [0-9a-fA-F]{2} cmd 01 payload\\[00 00 00 20 03 \\]",
                "T[0-9a-fA-F]{8}:TX \\(resp\\) Ucast 0x00",
});
expect("mn1", ".*T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x0000 \\(Basic\\) FC 00 seq [0-9a-fA-F]{2} cmd 0B payload\\[01 00 \\]");
networkWait(1000);

// Set the CLI to the coordinator network and try sending read attributes on
// the end device network.  Again, this should work.
send("mn1", "network set 0");
send("mn1", "zcl global read 0x0000 0x0000");
send("mn1", "send 0x0000 0x02 0x01");
expect("mn1", ".*T[0-9a-fA-F]{8}:TX \\(CLI\\) Ucast 0x00");
expect("coord2", "T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x0000 \\(Basic\\) FC 00 seq [0-9a-fA-F]{2} cmd 00 payload\\[00 00 \\]");
//expect("coord2", "T[0-9a-fA-F]{8}:TX \\(resp\\) Ucast 0x00");
expectMultiline("mn1",
                new String[] {
                  "T[0-9a-fA-F]{8}:RX len 8, ep 02, clus 0x0000 \\(Basic\\) FC 08 seq [0-9a-fA-F]{2} cmd 01 payload\\[00 00 00 20 03 \\]",
                  "T[0-9a-fA-F]{8}:TX \\(resp\\) Ucast 0x00",
                });
expect("coord2", "T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x0000 \\(Basic\\) FC 00 seq [0-9a-fA-F]{2} cmd 0B payload\\[01 00 \\]");
networkWait(1000);

// These are similar read attributes commands, except they use APS encryption
// because they are for the Time cluster.
send("ed0", "zcl global read 0x000A 0x0000");
send("ed0", "send 0x0000 0x01 0x01");
expect("ed0", ".*T[0-9a-fA-F]{8}:TX \\(CLI\\) Ucast 0x00 w/ link key");
expectMultiline("mn1",
                new String[] {
                  "T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x000A \\(Time\\) FC 00 seq [0-9a-fA-F]{2} cmd 00 payload\\[00 00 \\]",
                  "T[0-9a-fA-F]{8}:TX \\(resp\\) Ucast 0x00 w/ link key",
                });
expectMultiline("ed0",
                new String[] {
                  "T[0-9a-fA-F]{8}:RX len 11, ep 01, clus 0x000A \\(Time\\) FC 08 seq [0-9a-fA-F]{2} cmd 01 payload\\[([0-9a-fA-F]{2} ){8}\\]",
                  "T[0-9a-fA-F]{8}:TX \\(resp\\) Ucast 0x00 w/ link key",
                },
                5000);
expect("mn1", "T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x000A \\(Time\\) FC 00 seq [0-9a-fA-F]{2} cmd 0B payload\\[01 00 \\]");
networkWait(1000);
send("mn1", "zcl global read 0x000A 0x0000");
send("mn1", "send 0x0000 0x02 0x01");
expect("mn1", ".*T[0-9a-fA-F]{8}:TX \\(CLI\\) Ucast 0x00 w/ link key");
expect("coord2", "T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x000A \\(Time\\) FC 00 seq [0-9a-fA-F]{2} cmd 00 payload\\[00 00 \\]");
//expect("coord2", "T[0-9a-fA-F]{8}:TX \\(resp\\) Ucast 0x00 w/ link key");
expectMultiline("mn1",
                new String[] {
                  "T[0-9a-fA-F]{8}:RX len 11, ep 02, clus 0x000A \\(Time\\) FC 08 seq [0-9a-fA-F]{2} cmd 01 payload\\[([0-9a-fA-F]{2} ){8}\\]",
                  "T[0-9a-fA-F]{8}:TX \\(resp\\) Ucast 0x00 w/ link key",
                });
expect("coord2", "T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x000A \\(Time\\) FC 00 seq [0-9a-fA-F]{2} cmd 0B payload\\[01 00 \\]");
networkWait(1000);

// Another read attributes command, but this time to the wrong endpoint.  The
// single-network end device will send to the end device side of dual network
// device.  The message should be dropped.
send("ed0", "zcl global read 0x0000 0x0000");
send("ed0", "send 0x0000 0x01 0x02");
expect("ed0", ".*T[0-9a-fA-F]{8}:TX \\(CLI\\) Ucast 0x00");
expectMultiline("mn1",
                new String[] {
                  "T[0-9a-fA-F]{8}:RX len 5, ep 02, clus 0x0000 \\(Basic\\) FC 00 seq [0-9a-fA-F]{2} cmd 00 payload\\[00 00 \\]",
                  "Drop cluster 0x0000 command 0x00 for endpoint 0x02 due to wrong network: 0",
                });
assert(network.expect("mn1", port, "T[0-9a-fA-F]{8}:TX.*", 1000, true) == null);
assert(network.expect("ed0", port, "T[0-9a-fA-F]{8}:RX.*", 1000, true) == null);
networkWait(1000);

// Similiar, except the read attributes message is sent to the broadcast
// endpoint and should be dropped on mismatched networks.
send("ed0", "zcl global read 0x0000 0x0000");
send("ed0", "send 0x0000 0x01 0xFF");
expect("ed0", ".*T[0-9a-fA-F]{8}:TX \\(CLI\\) Ucast 0x00");
expectMultiline("mn1",
                new String[] {
                  "T[0-9a-fA-F]{8}:RX len 5, ep FF, clus 0x0000 \\(Basic\\) FC 00 seq [0-9a-fA-F]{2} cmd 00 payload\\[00 00 \\]",
                  "Drop cluster 0x0000 command 0x00 for endpoint 0x02 due to wrong network: 0",
                });
networkWait(1000);

// Verify that service discovery works and that discovery can take place on
// each network at the same time.
send("mn1", "network set 0");
send("mn1", "option disc 0x0109 0x0000");
send("mn1"," network set 1");
send("mn1", "option disc 0x0109 0x0000");

// This code parses a particular line in the output and uses the data for further tests.
// In one case the "Match discovery.." below was immediately followed by a "poll nwk .." 
// and node2 took that latter value. Subsequent parsing will fail if that happens.
// So instead of searching for exact node id's, we check for two service discovery done messages.

// String node1 = expect("mn1", "Match discovery from 0x[0-9a-fA-F]{4}, ep 1");
// int i = node1.indexOf("0x");
// node1 = node1.substring(i, i + 6);
// assert(node1.equals("0x0000") || node1.equals(ed0));
// String node2 = expect("mn1", "Match discovery from 0x[0-9a-fA-F]{4}, ep 1");
// i = node2.indexOf("0x");
// node2 = node2.substring(i, i + 6);
// assert(!node1.equals(node2) && (node2.equals("0x0000") || node2.equals(ed0)));

expectMultiline("mn1",
                new String[] {
                  ".*Service discovery done.*",
                  ".*Service discovery done.*",
                });

networkWait(1000);
send("mn1", "network set 0");
send("mn1", "zdo ieee " + ed0);
send("mn1"," network set 1");
send("mn1", "zdo ieee 0x0000");
expectMultiline("mn1",
                new String[] {
                  "IEEE Address response: \\(>\\)(" + eui64("ed0") + "|" + eui64("coord2") + ")",
                  "IEEE Address response: \\(>\\)(" + eui64("ed0") + "|" + eui64("coord2") + ")",
                });
networkWait(5000);
send("mn1", "network set 0");
expect("mn1", "zdo nwk {" + eui64("ed0") + "}",
       "NWK Address response: " + ed0);
send("mn1"," network set 1");
expect("mn1", "zdo nwk {" + eui64("coord2") + "}",
       "NWK Address response: 0x0000", 
       2000);
networkWait(5000);

/** Price passthrough tests */

// Set up the routing parameters
send("mn1", "plugin mn-price-passthrough set-routing 0x0000 2 1");

// Put some prices on the "real" ESI
send("coord2", "plugin price-server who 0x01020304 \"price00\" 0x00000001");
send("coord2", "plugin price-server what 0x00 0x0000 0x00 0x00 0x00");
send("coord2", "plugin price-server when 0x00000001 0xFFFF");
send("coord2", "plugin price-server price 0x0000000A 0x01 0x00000005 0x00");
send("coord2", "plugin price-server alternate 0xFFFFFFFF 0xFF 0xFF");
send("coord2", "plugin price-server valid 0x01 0");
networkWait(1000);

// Start the poll and forward process.
send("mn1", "plugin mn-price-passthrough start");
expect("coord2", "RX: GetCurrentPrice 0x00", 2000);
expect("mn1", "RX: PublishPrice.*", 2000);

// Print the price table for the proxy ESI; ensure expectations are met
expectMultiline("mn1",
                "plugin mn-price-passthrough print",
                new String[] {
                  "= CURRENT PRICE =",
                  "  label: price00\\(07\\)",
                  "  uom/cur: 0x00/0x0000",
                  "  pid/eid: 0x01020304/0x00000001",
                  "  ct/st/dur: 0x[0-9a-fA-F]{8}/0x00000001/INF",
                  "  ptdt/ptrt: 0x00/0x00",
                  "  p/pr: 0x0000000A/0x01",
                  "  gp/gpr: 0x00000005/0x00",
                  "  acd/acu/actd: 0xFFFFFFFF/0xFF/0xFF",
                  "  price is valid from time 0x00000001 until eternity",
                });
networkWait(1000);

// Publish another price
send("coord2", "plugin price-server who 0x01020304 \"price02\" 0x00000003");
send("coord2", "plugin price-server what 0x00 0x0000 0x00 0x00 0x00");
send("coord2", "plugin price-server when 0x00000020 0xFFFF");
send("coord2", "plugin price-server price 0x0000000A 0x01 0x00000005 0x00");
send("coord2", "plugin price-server alternate 0xFFFFFFFF 0xFF 0xFF");
send("coord2", "plugin price-server valid 0x01 0");
networkWait(1000);

// The proxy polls every ten minutes for the current price, so wait fifteen to
// make sure we get the next one.
expect("coord2", "RX: GetCurrentPrice 0x00", 15 * 60 * 1024);
expect("mn1", "RX: PublishPrice.*", 2000);

// Print the price table for the proxy ESI; ensure expectations are met
expectMultiline("mn1",
                "plugin mn-price-passthrough print",
                new String[] {
                  "= CURRENT PRICE =",
                  "  label: price02\\(07\\)",
                  "  uom/cur: 0x00/0x0000",
                  "  pid/eid: 0x01020304/0x00000003",
                  "  ct/st/dur: 0x[0-9a-fA-F]{8}/0x00000020/INF",
                  "  ptdt/ptrt: 0x00/0x00",
                  "  p/pr: 0x0000000A/0x01",
                  "  gp/gpr: 0x00000005/0x00",
                  "  acd/acu/actd: 0xFFFFFFFF/0xFF/0xFF",
                  "  price is valid from time 0x00000020 until eternity",
                });
networkWait(1000);
