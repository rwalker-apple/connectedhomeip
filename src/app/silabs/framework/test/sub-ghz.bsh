import com.ember.peek.SimulatedNetwork;

source("util.bsh");

if (runArgument.runUsingMultihop) {
  // This tests find and joining the right network, which is always 1-hop.
  // No real point in testing multi-hop.
  std.print("**** Multihop doesn't make sense, skipping");
  return;
}

// Create network and load devices.
SimulatedNetwork network = createNetwork();
boolean noEcc = shouldSkipEccTest();
// Note that some numeric values are changed below based on ECC or not
// The presence or absence of ECC changes the duty cycle used, so
// the parameters testing it need adjustment

TestNode[] ncpNodes = noEcc
  ? new TestNode[] {
      new TestNode ("server",
          "",
          "build/af-test-apps/Se14CommsHub-simulation-ezsp/Se14CommsHub",
          "app/ncp/sample-app/xncp-commshub-spi-dual_simulation/simulation/build/exe/xncp-commshub-spi-dual",
          "build/transceiver-simulator-unix-simulation_trx/transceiver-simulator",
          new Location(1, 0))
    }
  : new TestNode[] {
      new TestNode ("server",
          "",
          "build/af-test-apps/Se14CommsHub-simulation-ezsp/Se14CommsHub",
          "app/ncp/sample-app/xncp-commshub-spi-dual_simulation-real_ecc/simulation/build/exe/xncp-commshub-spi-dual",
          "build/transceiver-simulator-unix-simulation_trx/transceiver-simulator",
          new Location(1, 0))
    };
addAndLoadDevicesWithLocationSim(ncpNodes, true);

//Two SoCs and Two NCPs
TestNode[] socNodes = noEcc
  ? new TestNode[] {
      new TestNode ("ihd",
          "build/af-test-apps/Se14Ihd-simulation/Se14Ihd",
          "",
          "",
          "",
          new Location(1, 1)),
      new TestNode ("ihd_2_4_ghz",
          "build/af-test-apps/Se14Ihd-simulation/Se14Ihd",
          "",
          "",
          "",
          new Location(1, 2)),
      new TestNode ("gmeter",
          "build/af-test-apps/Se14MeterGas-simulation/Se14MeterGas",
          "",
          "",
          "",
          new Location(1, 3))
    }
  : new TestNode[] {
      new TestNode ("ihd",
          "build/af-test-apps/Se14Ihd-simulation-REAL_ECC/Se14Ihd",
          "",
          "",
          "",
          new Location(1, 1)),
      new TestNode ("ihd_2_4_ghz",
          "build/af-test-apps/Se14Ihd-simulation-REAL_ECC/Se14Ihd",
          "",
          "",
          "",
          new Location(1, 2)),
      new TestNode ("gmeter",
          "build/af-test-apps/Se14MeterGas-simulation-REAL_ECC/Se14MeterGas",
          "",
          "",
          "",
          new Location(1, 3))
    };
addAndLoadDevicesWithLocationSim(socNodes, false);

// Form and join a network and set up encryption.
int channel = 13;
int power = 1;
int panId = 0xBABE;
String panIdString = Integer.toHexString(panId).toUpperCase();

int subGhzPage = 29;
int subGhzChannel = 6;
int subGhzChannel8bitEncoded = ((subGhzPage << 5) & 255) + subGhzChannel;

setNetworkParams(channel, power, panId);
setupEncryption();

String[] someDevices = new String[] { "server", "ihd", "ihd_2_4_ghz", "gmeter" };
boolean[] onSubGhz = { true, true, false, true } ;

formAndJoinDevicesWithSubGhz(someDevices, !noEcc, 12000, onSubGhz, subGhzPage, subGhzChannel);

// Cache some global values...
String serverNodeId = nodeId("server");
String ihdNodeId = nodeId("ihd");
String ihd24NodeId = nodeId("ihd_2_4_ghz");
String gmeterNodeId = nodeId("gmeter");
int extraTimeoutMs = 10000;

// Create some util functions.
void increaseDutyCycle(String device, boolean checkResp)
{
  // If we want to make the DC state become Limited, Critical
  // or Suspended, we should set checkResp to be false
  // so that we continue without raising an exception.
  for (int i = 0; i < 10 ; i++) {
    expect(device,
           "zcl global read 0 0",
           ".*cmd 0x00.*");
    networkWait(2000);

    if (checkResp) {
      expect(device,
             "send " + serverNodeId + " 1 1",
             ".*RX .* clus 0x0000 \\(Basic\\).*",
             extraTimeoutMs);
    } else {
      send(device,
           "send " + serverNodeId + " 1 1");
    }
    networkWait(2000);
  }
}

void verifyPerDeviceDutyCycle(boolean reset)
{
  send("server", "plugin sub-ghz limits print");
  if (reset) {
    expectMultiline("server",
                    new String[] {
                      ".*" + ihdNodeId.substring(2, 6) + ": 0.00%\\)",
                      ".*" + gmeterNodeId.substring(2, 6) + ": 0.00%\\)"
                    },
                    DEFAULT_TIMEOUT);
  } else {
    nexpectMultiline("server",
                    new String[] {
                      ".*" + ihdNodeId.substring(2, 6) + ": 0.00%\\)",
                      ".*" + gmeterNodeId.substring(2, 6) + ": 0.00%\\)"
                    },
                    DEFAULT_TIMEOUT);
  }
}

double getDutyCycle(String target)
{
  // The target can be Limited, Critical,
  // Suspend, Consumed or nodeId.
  String resp = expect("server",
                       "plugin sub-ghz limits print",
                       ".*" + target + ".*");
  double dutyCycle = Double.parseDouble(resp.split(":")[1].substring(1, 5));
  return dutyCycle;
}

// -- TEST 1 --
// Send the "Suspend ZLC Messages" command from the server to the client.
// This is the canonical case.
int suspedPeriod = 42;
String suspedPeriodString = Integer.toHexString(suspedPeriod).toUpperCase();

send("server",
     "plugin sub-ghz suspend-zcl-messages " + ihdNodeId + " 1 " + suspedPeriod);
expect("ihd",
       ".*RX .* clus 0x070B \\(Sub-GHz\\) .* cmd 00 payload\\[" + suspedPeriodString + " \\]");

// -- TEST 2 --
// Check that the suspend period has been applied and the client cannot send messages.
// The message must be suppressed with error 0x77 and not sent.
send("ihd",
     "zcl global read 0 0");    // Query ZCL version
expect("ihd",
       "send " + serverNodeId + " 1 1",
       "Error: CLI Send failed, status: 0x77");

// -- TEST 3 --
// Client asks the server what the remaining suspend time is.
// It should not have changed since TEST 1 as it is counted in minutes.
expect("ihd",
       "plugin sub-ghz get-suspend-status " + serverNodeId + " 1",
       ".*OK");                 // Special case command, allowed to send without triggering error 0x77
expect("server",
       ".*Sub-GHz server: client .* transmitting within its suspend period\\.");
expect("ihd",
       ".*RX .* clus 0x070B \\(Sub-GHz\\) .* cmd 00 payload\\[" + suspedPeriodString + " \\]");

// -- TEST 4 --
// Set client to ignore the suspend status and send a message regardless.
// The server must reply with "Suspend ZCL Messages" and not act on the message.
send("ihd",
     "plugin sub-ghz ignore-suspend-status 1");
send("ihd",
     "zcl global read 0 0");    // Query ZCL version
send("ihd",
     "send " + serverNodeId + " 1 1");
expect("server",
       ".*Sub-GHz server: client .* transmitting within its suspend period\\.");
expect("ihd",
       ".*RX .* clus 0x070B \\(Sub-GHz\\) .* cmd 00 payload\\[" + suspedPeriodString + " \\]");

// -- TEST 5 --
// Disable ignoring the suspend status and run TEST 4 again.
// Expect the same result as in TEST 2.
send("ihd",
     "plugin sub-ghz ignore-suspend-status 0");
send("ihd",
     "zcl global read 0 0");    // Query ZCL version
expect("ihd",
       "send " + serverNodeId + " 1 1",
       "Error: CLI Send failed, status: 0x77");

// -- TEST 6 --
// Wait a bit over a minute and re-run TEST 3.
// Check that the remaining suspend period has decreased.
std.print("Waiting a minute to decrease remaining suspend period...\n");
networkWait(65000);

suspedPeriod = suspedPeriod - 1;
suspedPeriodString = Integer.toHexString(suspedPeriod).toUpperCase();

expect("ihd",
       "plugin sub-ghz get-suspend-status " + serverNodeId + " 1",
       ".*OK");
expect("server",
       ".*Sub-GHz server: client .* transmitting within its suspend period\\.");
expect("ihd",
       ".*RX .* clus 0x070B \\(Sub-GHz\\) .* cmd 00 payload\\[" + suspedPeriodString + " \\]");

// Bonus: check the suspend timer of all clients on the server.
expect("server",
       "plugin sub-ghz client-status " + ihdNodeId,
       ".*: suspended for .*");
expect("server",
       "plugin sub-ghz client-status " + ihd24NodeId,
       ".*: not suspended");
expect("server",
       "plugin sub-ghz client-status " + gmeterNodeId,
       ".*: not suspended");

// -- TEST 7 --
// Cancel the suspend time (set it to 0).
// Check that the servers responds accordingly when the client queries the time
// and that the client can send messages again.
send("server",
     "plugin sub-ghz suspend-zcl-messages " + ihdNodeId + " 1 0");
expect("ihd",
       ".*RX .* clus 0x070B \\(Sub-GHz\\) .* cmd 00 payload\\[00 \\]");
expect("ihd",
       "plugin sub-ghz get-suspend-status " + serverNodeId + " 1",
       ".*OK");
expect("ihd",
       ".*RX .* clus 0x070B \\(Sub-GHz\\) .* cmd 00 payload\\[00 \\]");
send("ihd",
     "zcl global read 0 0");    // Query ZCL version
send("ihd",
     "send " + serverNodeId + " 1 1");
expect("server",
       "READ: clus 0000, attr 0000, dataLen: 01, OK");
expect("ihd",
       ".*RX .* clus 0x0000 \\(Basic\\) .* cmd 01 payload\\[.* \\]");

// -- TEST 8 --
// The server suspends a 2.4 GHz client.
// This is an invalid command and should receive a default response.
expect("server",
       "plugin sub-ghz suspend-zcl-messages " + ihd24NodeId + " 1 " + suspedPeriod,
       ".*RX .* clus 0x0000 \\(Basic\\) .* cmd 0B payload\\[.* \\]");

// -- TEST 9 --
// A client sends a "Suspend ZCL Messages" command to the server.
// This is also an illegal case rewarded with a default response with status = UNSUP_CLUSTER_COMMAND (0x81) .
expect("ihd",
       "plugin sub-ghz suspend-zcl-messages " + serverNodeId + " 1 " + suspedPeriod,
	   "No such command");
networkWait(timeout);           // Allow CLI to tell us off for the wrong syntax

// Try again manually, as a raw ZCL message.
send("ihd",
     "raw 0x070B {091000" + suspedPeriodString + "}");
send("ihd",
     "send " + serverNodeId + " 1 1");
expect("server",
       ".*RX .* clus 0x070B \\(Sub-GHz\\) .* cmd 00 payload\\[" + suspedPeriodString + " \\]");
expect("ihd",
       ".*RX .* clus 0x070B \\(Sub-GHz\\) .* cmd 0B payload\\[00 81 \\]");

// -- TEST 10 --
// Reduce the duty cycle limits to trigger the automatic action
// which is to suspend the most active device (in our case, "ihd") for 5 minutes.
expectMultiline("server",
                "plugin sub-ghz limits print",
                new String[] {
                  // See comment above re ECC changing duty cycle
                  noEcc ? ".*Consumed: 0.03%" : ".*Consumed: 0.04%",
                  ".*DC state: Normal"
                });
expect("server",
                  // See comment above re ECC changing duty cycle
       "plugin sub-ghz limits set "+ (noEcc ? "2" : "3") +" 5 7",
       ".*OK");
expect("ihd",
       ".*RX .* clus 0x070B \\(Sub-GHz\\) .* cmd 00 payload\\[05 \\]");
nexpect("gmeter",
        ".*RX .* clus 0x070B \\(Sub-GHz\\) .*");

// -- TEST 11 --
// Reduce the duty cycle limits even more to trigger suspending all non-sleepy devices.
expectMultiline("server",
                "plugin sub-ghz limits print",
                new String[] {
                  // See comment above re ECC changing duty cycle
                  noEcc ? ".*Consumed: 0.03%" : ".*Consumed: 0.04%",
                  ".*DC state: Limited"
                });
expect("server",
                  // See comment above re ECC changing duty cycle
       "plugin sub-ghz limits set " + (noEcc ? "1 2":"2 3") +" 5",
       ".*OK");
expect("gmeter",
       ".*RX .* clus 0x070B \\(Sub-GHz\\) .* cmd 00 payload\\[05 \\]");

if (noEcc) {
  // Reboot the IHD in the noEcc case to burn some more duty cycle
  // This works around teh issue that you can't set the limits
  // lower than 1, 2, 3 because they must each be greater than
  // the previous one
  expect("ihd",
         "reset",
         "EMBER_NETWORK_UP 0x....");
  networkWait(30000);
}

// -- TEST 12 --
// Reduce the duty cycle limits all the way down to shut the server off completely.
// Check that the IHD loses the link.
expectMultiline("server",
                "plugin sub-ghz limits print",
                new String[] {
                  noEcc ? ".*Consumed: 0.03%" : ".*Consumed: 0.04%",
                  ".*DC state: Critical"
                });
expect("server",
       "plugin sub-ghz limits set 1 2 3",
       ".*OK");
expectMultiline("server",
                "plugin sub-ghz limits print",
                new String[] {
                  noEcc ? ".*Consumed: 0.03%" : ".*Consumed: 0.04%",
                  ".*DC state: Suspended"
                });
expect("ihd",
       "EMBER_NETWORK_DOWN",
       60000);

// Reboot some devices before
// running the following tests.
reboot("server");
socReboot("ihd");
socReboot("gmeter");
networkWait(30000);

// -- TEST 13 --
// Check the per device duty cycle is not reset
// after a 2.4Ghz channel change.
int newChannel = 15;
increaseDutyCycle("ihd", true);
increaseDutyCycle("gmeter", true);
networkWait(5000);

verifyPerDeviceDutyCycle(false);

expect("server",
       "network change-channel " + newChannel,
       ".*Changing to channel.*");
networkWait(30000);
expectMultiline("server",
                "info",
                new String[] {
                  ".*chan \\[" + newChannel +"\\].*"
                });

verifyPerDeviceDutyCycle(false);
networkWait(10000);

// -- TEST 14 --
// Check the per device duty cycle is not reset
// after changing to the previous sub-ghz channel
// via multi-phy-start.
expect("server",
       "network multi-phy-stop",
       ".*Terminated multi-phy interface 0x00");
networkWait(10000);

expect("server",
       "network multi-phy-start " + subGhzPage + " " + subGhzChannel + " 0 0",
       "Started multi-phy interface");
expectMultiline("server",
                "info",
                new String[] {
                  ".*page \\[" + subGhzPage + "\\] chan \\[" + subGhzChannel + "\\].*"
                });

verifyPerDeviceDutyCycle(false);
networkWait(10000);

// -- TEST 15 --
// Check the per device duty cycle is reset
// after a sub-ghz channel change via multi-phy-start.
socReboot("ihd");
socReboot("gmeter");
networkWait(30000);

expect("server",
       "network multi-phy-stop",
       ".*Terminated multi-phy interface 0x00");
networkWait(10000);

int newSubGhzPage = 29;
int newSubGhzChannel = 5;
expect("server",
       "network multi-phy-start " + newSubGhzPage + " " + newSubGhzChannel + " 0 0",
       "Started multi-phy interface");
expectMultiline("server",
                "info",
                new String[] {
                  ".*page \\[" + newSubGhzPage + "\\] chan \\[" + newSubGhzChannel + "\\].*"
                });

verifyPerDeviceDutyCycle(true);
networkWait(10000);

// -- TEST 16 --
// Check the per device duty cycle is reset
// after a sub-ghz channel change via
// plugin comms-hub-function-sub-ghz
socReboot("ihd");
socReboot("gmeter");
networkWait(30000);

increaseDutyCycle("ihd", true);
increaseDutyCycle("gmeter", true);
networkWait(5000);

verifyPerDeviceDutyCycle(false);

// 0x000000A7 is Page 29, Channel 7
String newSubGhzPageChannelMask = "0x000000A7";
int newSubGhzPage = 29;
int newSubGhzChannel = 7;

send("server",
     "plugin sub-ghz channel-change set " + newSubGhzPageChannelMask);
networkWait(1000);

expect("server",
       "plugin sub-ghz channel-change print",
       ".*" + newSubGhzPageChannelMask);
networkWait(1000);

// The value of wakeUpPeriodMin should be
// EMBER_AF_PLUGIN_COMMS_HUB_FUNCTION_SUB_GHZ_GSME_WAKE_UP_PERIOD
int wakeUpPeriodMin = 30;
int msPerMin = 60000;

expect("server",
       "plugin comms-hub-function-sub-ghz channel-change-start",
       ".*OK");
networkWait(wakeUpPeriodMin * msPerMin + extraTimeoutMs);

expect("server",
       "plugin comms-hub-function-sub-ghz channel-change-complete " + newSubGhzPage + " " + newSubGhzChannel,
       ".*OK");
//For channel-change-complete we need to wait for two wakeup periods
networkWait(wakeUpPeriodMin * 2 * msPerMin + extraTimeoutMs);

expectMultiline("server",
                "info",
                new String[] {
                  ".*page \\[" + newSubGhzPage + "\\] chan \\[" + newSubGhzChannel + "\\].*"
                });

verifyPerDeviceDutyCycle(true);
networkWait(10000);

// -- TEST 17 --
// Verify per device duty cycle
// get decreased during an idle period.
reboot("server");
networkWait(10000);
socReboot("ihd");
socReboot("gmeter");
networkWait(30000);

expect("server",
       "plugin sub-ghz limits set 10 20 30",
       ".*OK");
networkWait(2000);

// Increase duty cycle for both devices
for (int i = 0; i < 3; i++) {
  increaseDutyCycle("ihd", true);
  increaseDutyCycle("gmeter", true);
}
verifyPerDeviceDutyCycle(false);
expect("server",
       "plugin sub-ghz limits print",
       ".*DC state: Normal");

// Increase duty cycle to reach the limited state and
// the gmeter will have a higher per-device duty cycle,
// thus it will be suspended.
for (int i = 0; i < 5; i++) {
  increaseDutyCycle("gmeter", false);
}
expect("server",
       "plugin sub-ghz limits print",
       ".*DC state: Limited");
networkWait(2000);
expect("server",
       "plugin sub-ghz client-status " + ihdNodeId,
       ".*not suspended.*");
networkWait(2000);
expect("server",
       "plugin sub-ghz client-status " + gmeterNodeId,
       ".*suspended for.*");

// Cache some variables
int dcPeriodMs = 3600000; // 1 hour
int dcBucketMs = 300000;  // 5 minutes
double consumedDutyCycle = getDutyCycle("Consumed");
double ihdDutyCycle = getDutyCycle(ihdNodeId.substring(2, 6));
double gmeterDutyCycle = getDutyCycle(gmeterNodeId.substring(2, 6));
double curConsumedDutyCycle = 0;
double curIhdDutyCycle = 0;
double curGmeterDutyCycle  = 0;
networkWait(5000);

// Power off end devices to make
// per device duty cycle decrease
network.power("ihd", false);
network.power("gmeter", false);
for (int i = 0; i < dcPeriodMs / dcBucketMs; i++) {
  // Duty cycle gets updated every dcBucketMs
  networkWait(dcBucketMs + extraTimeoutMs);
  curConsumedDutyCycle = getDutyCycle("Consumed");
  curIhdDutyCycle = getDutyCycle(ihdNodeId.substring(2, 6));
  curGmeterDutyCycle  = getDutyCycle(gmeterNodeId.substring(2, 6));

  // Verify per device duty cycle is decreasing
  if ((curConsumedDutyCycle < consumedDutyCycle)
      && (curIhdDutyCycle != 0)
      && (curGmeterDutyCycle != 0)) {
    assert(curIhdDutyCycle < ihdDutyCycle);
    assert(curGmeterDutyCycle < gmeterDutyCycle);
    consumedDutyCycle = curConsumedDutyCycle;
    ihdDutyCycle = curIhdDutyCycle;
    gmeterDutyCycle = curGmeterDutyCycle;
  }
}

// Per device duty cycle will decrease to 0
// and DC state will be back to normal.
assert(curIhdDutyCycle == 0);
assert(curGmeterDutyCycle == 0);
expect("server",
       "plugin sub-ghz limits print",
       ".*DC state: Normal");

// Power on end devices and we should
// be able to talk to end devices again.
network.power("ihd", true);
network.power("gmeter", true);
setupEncryption();
networkWait(30000);
increaseDutyCycle("ihd", true);
increaseDutyCycle("gmeter", true);
verifyPerDeviceDutyCycle(false);

// -- TEST 18 --
// Verify per device duty cycle of each end device
// can increase and decrease properly.
reboot("server");
networkWait(10000);
socReboot("ihd");
socReboot("gmeter");
networkWait(30000);

// Feed data to all DC buckets of ihd in 1 hour
for (int i = 0; i < 60; i++ ) {
  // The increaseDutyCycle() will take about
  // 50 seconds, so here is 60 seconds elapsed.
  increaseDutyCycle("ihd", true);
  networkWait(extraTimeoutMs);
}
ihdDutyCycle = getDutyCycle(ihdNodeId.substring(2, 6));
gmeterDutyCycle = getDutyCycle(gmeterNodeId.substring(2, 6));
networkWait(2000);

// During this 15 minutes, make gmeter talk to
// the server, but not ihd.
for (int i = 0; i < 15; i++ ) {
  // The increaseDutyCycle() will take about
  // 50 seconds, so here is 60 seconds elapsed.
  increaseDutyCycle("gmeter", true);
  networkWait(extraTimeoutMs);
}

// Per-device duty cycle of ihd should decrease
assert(getDutyCycle(ihdNodeId.substring(2, 6)) < ihdDutyCycle);
// Per-device duty cycle of gmeter should increase
assert(getDutyCycle(gmeterNodeId.substring(2, 6)) > gmeterDutyCycle);
