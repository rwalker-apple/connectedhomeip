import com.ember.peek.SimulatedNetwork;

source("util.bsh");

if (runArgument.runUsingMultihop) {
  std.print("**** No multi-hop ****");
  return;
}

if (!runArgument.runUsingHostApps) {
  // The Z3 Gateway can only be compiled as a host
  std.print("** this test is only run in host mode ** ");
  return;
}

SimulatedNetwork network = createNetwork();
// Load Z3Gateway app as HOST.
Location gatewayLocation = gridLocations[0];
TestNode gateway = new TestNode("gateway",
                                "", // no SoC image
                                "build/af-test-apps/Z3GatewayWithWwah-simulation-ezsp/Z3GatewayWithWwah",
                                "app/ncp/sample-app/mn-ncp-uart/simulation/build/exe/mn-ncp-uart",
                                gatewayLocation);
addAndLoadDevicesWithLocation(new TestNode[] { gateway }, true, false); // useHost, don't useSpi

int numRouterDevices = 5; // One larger than SURVEY_BEACON_RESULT_LIMIT
for (int i=1; i <= numRouterDevices; i++) {
  Location routerLocation = gridLocations[i];
  TestNode router = new TestNode("light" + i,
                                 "build/af-test-apps/Z3LightWithWwah-simulation/Z3LightWithWwah",
                                 "",
                                 "",
                                 routerLocation);
  addAndLoadDevicesWithLocation(new TestNode[] { router }, false);
}

Location endDeviceLocation = gridLocations[numRouterDevices+1];
TestNode endDevice = new TestNode("door-lock",
                                  "build/af-test-apps/Z3DoorLockWithWwah-simulation/Z3DoorLockWithWwah",
                                  "",
                                  "",
                                  endDeviceLocation);
addAndLoadDevicesWithLocation(new TestNode[] { endDevice }, false);

lazyExpect = true;

void startNetwork()
{
  setupEncryption();

  // Wait for the nodes to reset. The Z3 Light will automatically start a network on boot
  // if its network steering fails. Since it starts this process before we form our centralized
  // network, we need to wait for all the the steering to end, leave all the formed networks,
  // create a centralized network, and then restart the steering process on each node.
  networkWait(105000);

  for (int i = 1; i <= numRouterDevices; i++) {
    send("light" + i, "net leave"); 
  }
  networkWait(5000);  
  // The gateway forms a centralized network.
  expect("gateway", "plugin network-creator start 1",
         "NWK Creator: Form. Channel.*Status: 0x00",
         DEFAULT_TIMEOUT << 1);

  // Open the network for joining using the gateway.
  expect("gateway", "plugin network-creator-security open-network", ".*Open network: 0x00");

  for (int i = 1; i <= numRouterDevices; i++) {
    send("light" + i, "plugin network-steering start 0");    
    networkWait(25000);
  }
  send("gateway", "info");
  networkWait(5000);
  for (int i = 1; i <= numRouterDevices; i++) {
    expect("light" + i, "info", "panID \\[" + panId("gateway") + "\\]", 1000);
    networkWait(5000);
  }
  
  expect("gateway", "plugin network-creator-security open-network", ".*Open network: 0x00");
  networkWait(10000);

  networkWait(30000);
  send("door-lock", "plugin network-steering start 0");
  expect("door-lock",
         "EMBER_NETWORK_UP",
         DEFAULT_TIMEOUT << 4);
  expect("door-lock",
         "Trust center link key update status: 0x65",
         DEFAULT_TIMEOUT << 4);

}

String swapNodeIdEndianess(String id)
{
  return id.substring(4,6) + " " + id.substring(2,4);
}

void testEnhancedBeaconCall()
{
  // Make sure there's an entry in the address table first
  // TODO We can remove this once EMZIGBEE-3518 is implemented
  String doorlockEui = eui64("door-lock");
  String doorlockEuiLittleEndian = getEui64LittleEndian("door-lock");
  send("gateway", "plugin address-table add {" + doorlockEuiLittleEndian + "}");
  send("gateway", "zdo nwk {" + doorlockEui + "}");
  networkWait(5000);

  // Ensure that we return a default response with an error code when specifying to use enhanced
  // beacons. This behavior will change when enhanced beacons are implemented for survey beacons.
  send("gateway", "zcl mfg-code 0x1217");
  send("gateway", "zcl sl-wwah survey-beacons 0");
  send("gateway", "send " + nodeId("door-lock") + " 1 1");  // this is fragile because 
  // it depends on the address table entry not being over written
  expect("gateway","DEFAULT_RESP: \\(SL Works With All Hubs\\) cmd 13 status 85",10000);
}

void testLargeNetworkSurveyFilter()
{
  // Get the basic info from the devices
  String doorLockNodeId = nodeId("door-lock");
  String doorlockEui = eui64("door-lock");
  String doorlockEuiLittleEndian = getEui64LittleEndian("door-lock");
  String[] lightsNodeId = new String[numRouterDevices + 1];
  String[] lightsEui = new String[numRouterDevices + 1];
  String[] lightsEuiLittleEndian = new String[numRouterDevices + 1];
  for(int i = 1; i <= numRouterDevices; i++) {
    lightsNodeId[i] = nodeId("light" + i);
    lightsEui[i] = eui64("light" + i);
    lightsEuiLittleEndian[i] = getEui64LittleEndian("light" + i);
  }

  // Setup prioritization algorithm filtering data
  send("gateway","debugprint all_off");
  for (int i = 1; i <= numRouterDevices; i++) {
    send("light" + i,"debugprint all_off");
  }
  send("door-lock","debugprint all_off");
  networkWait(10 * 60 * 1000); // 10 minutes in microseconds -- allow for long uptime to be set
  send("gateway","debugprint all_on");
  for (int i = 1; i <= numRouterDevices; i++) {
    send("light" + i,"debugprint all_on");
  }
  send("door-lock","debugprint all_on");

  // Enable parent classification on the lights
  for (int i = 1; i <= numRouterDevices; i++) {
    // Make sure the gateway has each light in its address table before sending out the ZCL command
    send("gateway", "plugin address-table add {" + lightsEuiLittleEndian[i] + "}");
    networkWait(2000);
    send("gateway", "zdo nwk {" + lightsEui[i] + "}");
    networkWait(2000);
    send("gateway", "zcl mfg-code 0x1217");
    send("gateway", "zcl sl-wwah enable-parent-classify");
    send("gateway", "send " + lightsNodeId[i] + " 1 1");
    networkWait(5000);
    // Avoid reaching the entry limit of the address table.
    send("gateway", "plugin address-table remove {" + lightsEuiLittleEndian[i] + "}");
    networkWait(2000);
  }

  // Enable parent classification on the doorlock
  // Make sure the gateway has the doorlock in its address table before sending out the ZCL command
  send("gateway", "plugin address-table add {" + doorlockEuiLittleEndian + "}");
  networkWait(2000);
  send("gateway", "zdo nwk {" + doorlockEui + "}");
  networkWait(2000);
  send("gateway", "zcl mfg-code 0x1217");
  send("gateway", "zcl sl-wwah enable-parent-classify");
  send("gateway", "send " + doorLockNodeId + " 1 1");
  networkWait(5000);

  // Make the last node worse and its long uptime turns back to the default
  socReboot("light" + numRouterDevices);
  networkWait(10000);

  // Keys print for easy debugging (network analyzer doesn't automatically include network key on such long logs)
  send("gateway", "keys print");
  networkWait(10000);

  // Send survey beacon request
  send("gateway", "zcl mfg-code 0x1217");
  send("gateway", "zcl sl-wwah survey-beacons 1");
  send("gateway", "send " + doorLockNodeId + " 1 1");

  // Get the payload from the response
  resp = expect("gateway", "cmd 09 payload", 20000);
  String payload = resp.split("payload")[1];

  // We should not have the beacon response from the the last node,
  // since we rebooted it before and its long uptime has not been set.
  String target = swapNodeIdEndianess(lightsNodeId[numRouterDevices]);
  assert(!payload.contains(target));

  // Beacon responses of other nodes inside the payload could be in a random order,
  // so here we check if we have enough number of beacon responses.
  int numBeaconResponses = 0;
  for (int i = 1; i < numRouterDevices; i++) {
    target = swapNodeIdEndianess(lightsNodeId[i]);
    if (payload.contains(target)) {
      numBeaconResponses++;
    }
  }
  assert(numBeaconResponses == numRouterDevices - 1);

  networkWait(20000);

  nexpect("gateway", "cmd 09 payload", 30000);
}

startNetwork();
testEnhancedBeaconCall();
testLargeNetworkSurveyFilter();
