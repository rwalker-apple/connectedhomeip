import com.ember.peek.SimulatedNetwork;

source("util.bsh");

if (runArgument.runUsingMultihop) {
  std.print("****TODO: Fix for multi-hop****");
  return;
}

SimulatedNetwork network = createNetwork();
String[] devices = new String[]{"remote", "light1", "light2", "harness", "harness2", "harness3", "harness4"};

// Note, we use a client-only initiator for this script.
String[] socImages = new String[] {
  "build/af-test-apps/ZllOnOffSwitch-simulation/ZllOnOffSwitch",
  "build/af-test-apps/ZllColorLight-simulation/ZllColorLight",
  "build/af-test-apps/ZllColorLight-simulation/ZllColorLight",
  "build/af-test-apps/TRaC_TestHarnessZ3-simulation/TRaC_TestHarnessZ3",
  "build/af-test-apps/TRaC_TestHarnessZ3-simulation/TRaC_TestHarnessZ3",
  "build/af-test-apps/TRaC_TestHarnessZ3-simulation/TRaC_TestHarnessZ3",
  "build/af-test-apps/TRaC_TestHarnessZ3-simulation/TRaC_TestHarnessZ3"
};
String[] hostImages = new String[] {
  "build/af-test-apps/ZllOnOffSwitch-simulation-ezsp/ZllOnOffSwitch",
  "build/af-test-apps/ZllColorLight-simulation-ezsp/ZllColorLight",
  "build/af-test-apps/ZllColorLight-simulation-ezsp/ZllColorLight",
  "build/af-test-apps/TRaC_TestHarnessZ3-simulation/TRaC_TestHarnessZ3", // non-ezsp placeholder
  "build/af-test-apps/TRaC_TestHarnessZ3-simulation/TRaC_TestHarnessZ3", // non-ezsp placeholder
  "build/af-test-apps/TRaC_TestHarnessZ3-simulation/TRaC_TestHarnessZ3", // non-ezsp placeholder
  "build/af-test-apps/TRaC_TestHarnessZ3-simulation/TRaC_TestHarnessZ3"  // non-ezsp placeholder
};
String ncpImage = "app/ncp/sample-app/ncp-spi/simulation/build/exe/ncp-spi";

// Create network and load devices according to the runArguments provided.
addAndLoadDevices(devices, socImages, hostImages, ncpImage);

if (!runArgument.runUsingHostApps) {
  expect("harness", "plugin network-creator form 1 0xFAB1 3 20", "EMBER_NETWORK_UP 0x0000"); // use the Z3 plugin
  send("harness", "plugin zll-commissioning disable");
  expect("harness",
         "plugin test-harness packet-printing beacon-printing enable",
         ".*Successfully enabled printing.");

  expect("harness2", "plugin network-creator form 1 0xFAB1 3 15", "EMBER_NETWORK_UP 0x0000"); // use the Z3 plugin
  send("harness2", "plugin zll-commissioning disable");
  expect("harness2",
         "plugin test-harness packet-printing beacon-printing enable",
         ".*Successfully enabled printing.");
         
  // Disable touchlink on the spare harnesses.
  send("harness3", "plugin zll-commissioning disable");
  send("harness4", "plugin zll-commissioning disable");
}

setupEncryption();

if (runArgument.runUsingMfgSecurityToken) {
  for (i = 0; i < devices.length; i++) {
    expectNoResponse(devices[i],
                   "security mfg-token set 0xCABAD11F 0");
    networkWait(2000);
    expect(devices[i], 
           "security mfg-token get",
           "  Permissions: NONE");
    networkWait(2000);
  }
}

if (runArgument.runUsingHostApps)  {
  // Not required for host.
  power("harness", false);
  power("harness2", false);
  power("harness3", false);
  power("harness4", false);
}

// The remote is mostly a blank slate when it starts.  It has the default
// channel sets and is factory new, but is otherwise uninitialized.
expectMultiline("remote", 
                "plugin zll-commissioning status",
                new String[] {
                ".*Primary channels: 11, 15, 20, 25 \\(0x02108800\\)",
                "Secondary channels: 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 26 \\(0x05EF7000\\)",
                "ZLL Tokens",
                "Bitmask: 0x00000083",  // addr assignment capable and interop bits now set
                "Free Node IDs,  Min: 0x0000, Max: 0x0000",
                "Free Group IDs, Min: 0x0000, Max: 0x0000",
                "My Group ID Min: 0x0000",
                "RSSI Correction: 0",
                "Security Bitmask: 0x00000000",
                // Security is set up for an unjoined factory-new touchlink device
                "Security Key Index: 15",
                "Security Encryption Key: C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF  "
                });

//--------------------------------------------------
// Test 1 - Touch link the first light from the remote. For the first touchlink, we
// will not form a network on the light first, in order to test the new
// factory new functionality.
// The first light should state that it is a ZigBee 3.0 device when it forms
// a network.

// However, light2 will also now reply to the scan request, unless we
// tell it to disable touchlinking. (We could also turn its radio off
// for the first two tests, since it's childless at this stage.)
send("light2", "plugin zll-commissioning disable");
expect("light1", "plugin zll-commissioning status", "Bitmask: 0x00000081");  // FN + interop
send("remote", "plugin zll-commissioning link");
expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);

// Ensure that an active scan is performed on the primary channel set during a Network Start procedure
if (!runArgument.runUsingHostApps) {
  expect("harness2", "beacon-req:rx", timeout * 10); // harness 2 is on channel 15 which has a scan performed second
  expect("harness", "beacon-req:rx", timeout * 10); // harness 1 is on channel 20 which has a scan performed third
}

expectNetworkUp("light1", timeout * 10);
expect("light1", "Touch link with 0x0001 \\(\\(>\\)" + eui64("remote") + "\\) complete");
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light1") + "\\) complete");

// Return test harness apps to their original state
if (!runArgument.runUsingHostApps) {
  send("harness","net leave");
  send("harness2","net leave");
  networkWait(5000);
}

// And now the remote is not factory new and has address ranges. Plus, it retains
// its ZigBee 3.0 device state.
expectMultiline("remote",
                "plugin zll-commissioning status",
                new String[] {
                ".*Primary channels: 11, 15, 20, 25 \\(0x02108800\\)",
                "Secondary channels: 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 26 \\(0x05EF7000\\)",
                "ZLL Tokens",
                "Bitmask: 0x00000092",  // Initiator bit now s
                "Free Node IDs,  Min: 0x0003, Max: 0xFFF7",
                "Free Group IDs, Min: 0x0021, Max: 0xFEFF",
                "My Group ID Min: 0x0000",
                "RSSI Correction: 0",
                "Security Bitmask: 0x00000000",
                "Security Key Index: 15",
                "Security Encryption Key: C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF  ",
                });

// And the light is also not factory new and otherwise a blank slate. It should
// remain a ZigBee 3.0 device.
expectMultiline("light1",
                "plugin zll-commissioning status",
                new String[] {
                ".*Primary channels: 11, 15, 20, 25 \\(0x02108800\\)",
                "Secondary channels: 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 26 \\(0x05EF7000\\)",
                "ZLL Tokens",
                "Bitmask: 0x00000080",
                "Free Node IDs,  Min: 0x0000, Max: 0x0000",
                "Free Group IDs, Min: 0x0000, Max: 0x0000",
                "My Group ID Min: 0x0001",
                "RSSI Correction: 0",
                "Security Bitmask: 0x00000000",
                "Security Key Index: 15",
                "Security Encryption Key: C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF  "
                });

//--------------------------------------------------
// Test 2 - Make the first light leave, then touchlink again, in order to test the
// radio-on-at-startup suspend/resume mechanism. Note that the node id's
// differ this time, because the initiator is no longer factory new.
expect("light1", "network leave", ".*EMBER_NETWORK_DOWN", timeout * 5);
send("remote", "plugin zll-commissioning link");
expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light1", timeout * 10);
expect("light1", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("remote") + "\\) complete");
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0x0003 \\(\\(>\\)" + eui64("light1") + "\\) complete");

//--------------------------------------------------
// Test 3 - Form a network on the second light and touch link from the remote, but using
// a different primary channel mask (the secondary mask remains the same, and overlaps
// the primary mask). For this test, we'll pay particular attention to the scan order.
send("light1", "plugin zll-commissioning disable");
send("light2", "plugin zll-commissioning enable");

// NOTE, remote is reset, but will still be parented by light1 on startup. (We'll test
// with an orphaned initiator in zll-end-device.bsh)
expect("remote", "reset", ".*.*EMBER_NETWORK_UP 0x0001");  // reset masks
setupEncryption();
expect("remote", "plugin zll-commissioning mask 1", ".*Primary channels: 12, 16, 21, 26 \\(0x04211000\\)");
expect("light2", "plugin zll-commissioning mask 1", ".*Primary channels: 12, 16, 21, 26 \\(0x04211000\\)");

if (!runArgument.runUsingHostApps) {
  // Set up our test harness nodes to listen for scan requests on selected channels.
  expect("harness",
         "plugin test-harness packet-printing beacon-printing disable",
         ".*Successfully disabled printing.");
  expect("harness2",
         "plugin test-harness packet-printing beacon-printing disable",
         ".*Successfully disabled printing.");
  expect("harness3",
         "plugin test-harness packet-printing beacon-printing disable",
         ".*Successfully disabled printing.");
  expect("harness4",
         "plugin test-harness packet-printing beacon-printing disable",
         ".*Successfully disabled printing.");
  expect("harness",
         "plugin test-harness packet-printing raw-printing enable",
         ".*Successfully enabled printing.");
  expect("harness2",
         "plugin test-harness packet-printing raw-printing enable",
         ".*Successfully enabled printing.");
  expect("harness3",
         "plugin test-harness packet-printing raw-printing enable",
         ".*Successfully enabled printing.");
  expect("harness4",
         "plugin test-harness packet-printing raw-printing enable",
         ".*Successfully enabled printing.");
  expect("harness",
         "plugin zll-commissioning channel 12",  // first primary and secondary channel
         ".*Setting default channel to 12");
  expect("harness2",
         "plugin zll-commissioning channel 26",  // last primary channel
         ".*Setting default channel to 26");
  expect("harness3",
         "plugin zll-commissioning channel 17",  // inside secondary channel
         ".*Setting default channel to 17");
  expect("harness4",
         "plugin zll-commissioning channel 25",  // unused channel
         ".*Setting default channel to 25");
}

startZllNetwork("light2", "16", "0", "0x1234", timeout * 10);
send("remote", "plugin zll-commissioning link");

if (!runArgument.runUsingHostApps) {
  // Expect five scans on the first primary channel.
  expect("harness", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 100);
  expect("harness", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 300);
  expect("harness", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 300);
  expect("harness", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 300);
  expect("harness", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 300);

  // One scan each on the last primary, the first secondary, the inside
  // secondary, and the last secondary.
  expect("harness2", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]");
  expect("harness",  ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]");
  expect("harness3", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]");
  expect("harness2", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]");
}

expect("light2", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light2", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light2", timeout * 10);
expect("light2", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("remote") + "\\) complete");
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0x0004 \\(\\(>\\)" + eui64("light2") + "\\) complete");

// Repeat, but this time check we don't get a scan on one of the unused channels.
expect("light2", "plugin zll-commissioning reset", ".*Setting default channel to ..");
expect("light2", "plugin zll-commissioning mask 1", ".*Primary channels: 12, 16, 21, 26 \\(0x04211000\\)");
startZllNetwork("light2", "16", "0", "0x1234", timeout * 10);
send("remote", "plugin zll-commissioning link");
if (!runArgument.runUsingHostApps) {
  nexpect("harness4", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]");
}
expectNetworkUp("light2", timeout * 10);
expect("light2", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("remote") + "\\) complete");
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0x0005 \\(\\(>\\)" + eui64("light2") + "\\) complete");

//------------------------------------
// Repeat, primary channels only.
expect("light2", "plugin zll-commissioning reset", ".*Setting default channel to ..");
expect("remote", "plugin zll-commissioning mask 0", ".*Primary channels: 11, 15, 20, 25 \\(0x02108800\\)");
expect("remote", "plugin zll-commissioning secondary-channel 0", ".*Secondary channels:  \\(0x00000000\\)");
startZllNetwork("light2", "25", "0", "0x1234", timeout * 10);

if (!runArgument.runUsingHostApps) {
  expect("harness",
         "plugin zll-commissioning channel 11",  // first primary channel
         ".*Setting default channel to 11");
  expect("harness2",
         "plugin zll-commissioning channel 25",  // last primary channel
         ".*Setting default channel to 25");
  expect("harness3",
         "plugin zll-commissioning channel 12",  // first secondary channel
         ".*Setting default channel to 12");
  expect("harness4",
         "plugin zll-commissioning channel 26",  // last secondary channel
         ".*Setting default channel to 26");
}

send("remote", "plugin zll-commissioning link");

if (!runArgument.runUsingHostApps) {
  // Expect five scans on the first primary channel.
  expect("harness", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 100);
  expect("harness", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 300);
  expect("harness", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 300);
  expect("harness", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 300);
  expect("harness", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 300);

  // One scan on the last primary.
  expect("harness2", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]");

  // Nothing on the first secondary.
  nexpect("harness3", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]");
}
expectNetworkUp("light2", timeout * 10);
expect("light2", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("remote") + "\\) complete");
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0x0006 \\(\\(>\\)" + eui64("light2") + "\\) complete");

//--------------------------
// Repeat, secondary channels only.
expect("light2", "plugin zll-commissioning reset", ".*Setting default channel to ..");
expect("remote", "reset", ".*.*EMBER_NETWORK_UP 0x0001");  // reset masks
setupEncryption();
expect("remote", "plugin zll-commissioning channel 0", ".*Primary channels:  \\(0x00000000\\)");

startZllNetwork("light2", "12", "0", "0x1234", timeout * 10);
send("remote", "plugin zll-commissioning link");

if (!runArgument.runUsingHostApps) {
  // Expect five scans on the first secondary channel.
  expect("harness3", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 100);
  expect("harness3", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 300);
  expect("harness3", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 300);
  expect("harness3", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 300);
  expect("harness3", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]", 300);

  // One scan on the last secondary.
  expect("harness4", ".*raw mac:rx 43 bytes \\[01 C8 .. FF FF FF FF .* \\]");
}

expectNetworkUp("light2", timeout * 10);
expect("light2", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("remote") + "\\) complete");
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0x0007 \\(\\(>\\)" + eui64("light2") + "\\) complete");

// Power off the second light so that it doesn't interfere with the rest of the
// touch links, and enable light1, which should still be parenting remote.
send("light1", "plugin zll-commissioning enable");
power("light2", false); // not used again

//--------------------------------------------------
// Test 4 - Restore the default channel masks, and touch link again.
// Because the devices are already on the same network, no
// network action should occur.  And, because no network action occurs, the
// stack will not call the ZllAddressAssignment handler.  Despite this, the
// plugin should still report the node id of the target as reported in the scan
// response (bug 13145).
expect("remote", "reset", ".*.*EMBER_NETWORK_UP 0x0001");  // reset masks
setupEncryption();

// remote and light1 should still be on the same network.
String chan1 = channel("light1");
networkWait(2000);
String chan2 = channel("remote");
networkWait(2000);
assert(chan1.equals(chan2));
String xpan1 = extendedPanId("light1");
networkWait(2000);
String xpan2 = extendedPanId("remote");
networkWait(2000);
assert(xpan1.equals(xpan2));

String nid1 = nodeId("light1");
networkWait(2000);
assert(nid1.equals("0x0003"));

expect("remote", "plugin zll-commissioning mask 0", ".*Primary channels: 11, 15, 20, 25 \\(0x02108800\\)");
send("remote", "plugin zll-commissioning link");
expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("remote", "Touch link with 0x0003 \\(\\(>\\)" + eui64("light1") + "\\) complete", timeout * 10);
expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);

// check that light1 hasn't been touchlinked.
String nid1b = nodeId("light1");
networkWait(2000);
assert(nid1b.equals(nid1));

//--------------------------------------------------
// Test 5 - Miscellaneous commands.
// First, reset the light and touch link again.
send("remote", "plugin zll-commissioning scan reset");
expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("remote", "Touch link with 0x0003 \\(\\(>\\)" + eui64("light1") + "\\) complete", timeout * 10);
expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expect("light1", "RX: ResetToFactoryNewRequest 0x[0-9a-fA-F]{8}");
expect("light1", "EMBER_NETWORK_DOWN");

startZllNetwork("light1", "20", "0", "0x1234", timeout * 10);
send("remote", "plugin zll-commissioning link");
expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light1", timeout * 10);
expect("light1", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("remote") + "\\) complete");
expectNetworkUp("remote", timeout * 100);
expect("remote", "Touch link with 0x0008 \\(\\(>\\)" + eui64("light1") + "\\) complete");

String nid1 = nodeId("light1");
assert(nid1.equals("0x0008"));
String nid2 = nodeId("remote");
assert(nid2.equals("0x0001"));

// Send a Device Information Request command to the light.
send("remote", "plugin zll-commissioning scan device");
expect("light1", ".*RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expectMultiline("remote", 
                new String[] {
                "Touch link with " + nid1 + " \\(\\(>\\)" + eui64("light1") + "\\) complete",
                "sub device 0: 0x01 0x0104 0x0200 0x02 0x20" // light1 now should have 32 group identifiers of its own.
                }, timeout * 10);

// The following line sometimes appears before the "Touch link with" line,
// causing the script to fail on host or SOC.
expect("light1", ".*RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);

// Send an Identify Request command to the light.
send("remote", "plugin zll-commissioning scan identify");
expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("remote", "Touch link with " + nid1 + " \\(\\(>\\)" + eui64("light1") + "\\) complete", timeout * 10);
expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000");

// Send a Get Group Identifiers Request command from client to server only.
send("remote", "plugin zll-commissioning groups " + nid1 + " 0x01 0x01 0x00");
expect("light1", "RX: GetGroupIdentifiersRequest 0x00");
expect("remote", "RX: GetGroupIdentifiersResponse 0x20, 0x00, 0x19, .*");  // 32 total, 25 in this msg
expect("light1", "DEFAULT_RESP: \\(ZLL Commissioning\\) cmd 41 status 00");

// Send a Get Endpoint List Request command from client to server only.
send("remote", "plugin zll-commissioning endpoints " + nid1 + " 0x01 0x01 0x00");
expect("light1", "RX: GetEndpointListRequest 0x00");
expect("remote", "RX: GetEndpointListResponse 0x00, 0x00, 0x00,");
expect("light1", "DEFAULT_RESP: \\(ZLL Commissioning\\) cmd 42 status 00");

// Send an Endpoint Information command from server to client only. Note that we
// now default to Zigbee 3.0 support in the zll-commissioning-common plugin, therefore
// we send the actual profile of the endpoint, not the ZLL profile id.
send("light1", "plugin zll-commissioning info " + nid2 + " 0x01 0x01");
expect("remote", "RX: EndpointInformation \\(>\\)" + eui64("light1") + ", " + nid1 + ", 0x01, 0x0104, 0x0200, 0x02");
expect("light1", "DEFAULT_RESP: \\(ZLL Commissioning\\) cmd 40 status 00");

// Use the buttons to control the light.
network.pressButton("remote", "1");
network.releaseButton("remote", "1");
expect("remote", "Broadcasting \"on\" command");
expect("light1", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 01 payload\\[\\]");
expect("light1", "Light on 0x01 is now ON");
network.pressButton("remote", "0");
network.releaseButton("remote", "0");
expect("remote", "Broadcasting \"off\" command");
expect("light1", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 00 payload\\[\\]");
expect("light1", "Light on 0x01 is now OFF");

// Verify that we remember our ZLL tokens after reboot.
expectMultiline("remote",
                "plugin zll-commissioning status",
                new String[] {
                ".*Primary channels: 11, 15, 20, 25 \\(0x02108800\\)",
                "Secondary channels: 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 26 \\(0x05EF7000\\)",
                "ZLL Tokens",
                "Bitmask: 0x00000092",    // Initiator bit now s
                "Free Node IDs,  Min: 0x0009, Max: 0xFFF7",
                "Free Group IDs, Min: 0x00E1, Max: 0xFEFF",
                "My Group ID Min: 0x0000",
                "RSSI Correction: 0",
                "Security Bitmask: 0x00000000",
                "Security Key Index: 15",
                "Security Encryption Key: C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF  "
                });

// Allow remote to poll before resetting.
networkWait(10000);
expect("remote", "reset", "EMBER_NETWORK_UP.*");
setupEncryption();

expectMultiline("remote", 
                "plugin zll-commissioning status",
                new String[] {
                "Primary channels: 11, 15, 20, 25 \\(0x02108800\\)",
                "Secondary channels: 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 26 \\(0x05EF7000\\)",
                "ZLL Tokens",
                "Bitmask: 0x00000092",  // Initiator bit now s
                "Free Node IDs,  Min: 0x0009, Max: 0xFFF7",
                "Free Group IDs, Min: 0x00E1, Max: 0xFEFF",
                "My Group ID Min: 0x0000",
                "RSSI Correction: 0",
                "Security Bitmask: 0x00000000",
                "Security Key Index: 15",
                "Security Encryption Key: C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF  "
                });

//--------------------------------------------------
// Test 6 - Beacon tests, to check that a router target does a scan before forming.
// (we'll do SoC only, to avoid having to define a new EZSP command or mess with XNCP)
if (!runArgument.runUsingHostApps) {
  // Set up a test harness device to listen for beacon requests on channel 20
  // (remote is touchlinked with (and parented by) light1 at this point)
  power("harness", true);
  setupEncryption();
  expect("harness", "plugin network-creator form 1 0xFAB1 3 20", "EMBER_NETWORK_UP 0x0000"); // use the Z3 plugin
  
  send("harness", "plugin zll-commissioning disable");
  expect("harness",
         "plugin test-harness packet-printing beacon-printing enable",
         ".*Successfully enabled printing.");

  // We need to restrict the target to a single channel, so we know where to listen.
  expect("light1", "plugin zll-commissioning channel 20", ".*Primary channels: 20 \\(0x00100000\\)");
  
  expect("remote", "network leave", ".*EMBER_NETWORK_DOWN", timeout * 5);
  send("remote", "plugin zll-commissioning link");

  expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
  expect("light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);

  // Expect a beacon request sent by light1.
  expect("harness", "beacon-req:rx");

  expectNetworkUp("light1", timeout * 10);
  expect("light1", "Touch link with 0x0001 \\(\\(>\\)" + eui64("remote") + "\\) complete");

  expectNetworkUp("remote", timeout * 10);
  expect("remote", "Touch link with 0x000. \\(\\(>\\)" + eui64("light1") + "\\) complete");

  zllChannel = channel("remote");
  assert(zllChannel.equals("20"));
  networkWait(10000);
}

//--------------------------------------------------
// Test 7 - MAC header tests. We'll use a test harness again, this time as the touchlink
// initiator, so we can inspect the raw message contents. SoC only again.
if (!runArgument.runUsingHostApps) {
  
  // Get the devices in the correct state.
  power("remote", false);
  expect("harness", "network leave", ".*EMBER_NETWORK_DOWN", timeout * 5);
  networkWait(5000);
  send("harness", "reset");
  networkWait(500);
  setupEncryption();
  send("harness", "plugin zll-commissioning enable");
  
  // Touchlink from Test Harness to light.
  expect("harness",
         "plugin test-harness packet-printing raw-printing enable",
         ".*Successfully enabled printing.");
  send("harness", "plugin zll-commissioning link");
  
  // First, check that we have a valid pan id in the Mac header for the scan response.
  info = expect("harness", ".*raw mac:rx 79 bytes \\[01 CC .. FF FF 00 00 00 00 00 00 00 04 .. .. 00 00 00 00 00 00 00 02 .*\\]", timeout * 2);
  i = info.indexOf("[") + 13 * 3 + 1;
  panMac = info.substring(i, i + 5);
  assert(!panMac.equals("00 00"));
  assert(!panMac.equals("FF FF"));
  
  // Next, check that the pan id in the payload matches that in the Mac header.
  i = info.indexOf("[") + 56 * 3 + 1;
  panAps = info.substring(i, i + 5);
  assert(panAps.equals(panMac));
  
  // Also, check that we have a valid channel in the payload.
  i = info.indexOf("[") + 55 * 3 + 1;
  chan = Integer.parseInt(info.substring(i, i + 2), 16);
  assert(chan >= 11);
  assert(chan <= 26);
  
  // Save the source pan id (whole line) for the scan response.
  sourceAddress = expect("harness", "sourceEui64:.*"); 
  
  // Harness forms a network, since it is a router.
  expect("harness", "EMBER_NETWORK_UP 0x0001", timeout * 5);
  expect("harness", "NWK Creator: Form. Channel: ... Status: 0x00");
  
  // Light goes down, then sends network join router response.
  expect("harness", "Sending join request to target");
  expect("light1", "EMBER_NETWORK_DOWN");
  info = expect("harness", "raw mac:rx 49 bytes \\[01 CC .. FF FF 00 00 00 00 00 00 00 04 .. .. 00 00 00 00 00 00 00 02 .*\\]");

  // Check that we have the same pan id in the Mac header as for the scan response.
  i = info.indexOf("[") + 13 * 3 + 1;
  panMac2 = info.substring(i, i + 5);
  assert(panMac2.equals(panMac));
  
  // Check that we have the same source address in the Mac header also.
  sourceAddress2 = expect("harness", "sourceEui64:.*");
  assert(sourceAddress2.equals(sourceAddress));
  
  expect("light1", "EMBER_NETWORK_UP 0x0002");
  expect("light1", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("harness") + "\\) complete");

  expect("harness", "EMBER_NETWORK_UP 0x0001");
  // Test harness doesn't do this message.
  // expect("remote", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light1") + "\\) complete");

  networkWait(50000);
}
