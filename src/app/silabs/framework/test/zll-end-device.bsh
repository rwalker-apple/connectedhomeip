import com.ember.peek.SimulatedNetwork;

source("util.bsh");

if (runArgument.runUsingMultihop) {
  std.print("****TODO: Fix for multi-hop****");
  return;
}

// Create four nodes in the network.
SimulatedNetwork network = createNetwork();
String[] devices = new String[]{"remote1", "remote2", "light", "light2"};

String[] socImages = new String[] {
  "build/af-test-apps/ZllColorSceneRemote-simulation/ZllColorSceneRemote",
  "build/af-test-apps/ZllColorSceneRemote-simulation/ZllColorSceneRemote",
  "build/af-test-apps/ZllColorLight-simulation/ZllColorLight",
  "build/af-test-apps/ZllColorLight-simulation/ZllColorLight",
};
String[] hostImages = new String[] {
  "build/af-test-apps/ZllColorSceneRemote-simulation-ezsp/ZllColorSceneRemote",
  "build/af-test-apps/ZllColorSceneRemote-simulation-ezsp/ZllColorSceneRemote",
  "build/af-test-apps/ZllColorLight-simulation-ezsp/ZllColorLight",
  "build/af-test-apps/ZllColorLight-simulation-ezsp/ZllColorLight",
};
String ncpImage = "app/ncp/sample-app/ncp-spi/simulation/build/exe/ncp-spi";

// Create network and load devices according to the runArguments provided.
addAndLoadDevices(devices, socImages, hostImages, ncpImage);
setupEncryption();

// Both remotes should start factory new with null address ranges.
send("remote1", "plugin zll-commissioning status");
expect("remote1", "Bitmask: 0x00000083");  // addr assignment capable + interop bits now set
expect("remote1", "Free Node IDs,  Min: 0x0000, Max: 0x0000");
expect("remote1", "Free Group IDs, Min: 0x0000, Max: 0x0000");
expect("remote1", "My Group ID Min: 0x0000");
send("remote2", "plugin zll-commissioning status");
expect("remote2", "Bitmask: 0x00000083");  // addr assignment capable + interop bits now set
expect("remote2", "Free Node IDs,  Min: 0x0000, Max: 0x0000");
expect("remote2", "Free Group IDs, Min: 0x0000, Max: 0x0000");
expect("remote2", "My Group ID Min: 0x0000");

// Power off the second light (to avoid it cluttering up the log), and disable touchlinking
// on the second remote until required.
power("light2", false);
send("remote2", "plugin zll-commissioning disable");

//-----------------------------------------------------------------------------
// 1) Form a network on the light and touch link from the first remote.

// No point forming a network on 25, since light will get stolen...
// startZllNetwork("light", "25", "0", "0x1234", timeout * 10);

// Network will be established on one of the primary channels.
send("remote1", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("remote1") + "\\) complete", timeout * 10);
expectNetworkUp("remote1", timeout * 10);
expect("remote1", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete", timeout * 10);

// The first remote should no longer be factory new and should have the default
// address ranges. Plus, it should state itself as a ZigBee 3.0 device
// since it has touch linked.
send("remote1", "plugin zll-commissioning status");
expect("remote1", "Bitmask: 0x00000092");  // Initiator bit now set
expect("remote1", "Free Node IDs,  Min: 0x0003, Max: 0xFFF7");
expect("remote1", "Free Group IDs, Min: 0x0041, Max: 0xFEFF");
expect("remote1", "My Group ID Min: 0x0001");
networkWait(2000); // remaining lines...

//-----------------------------------------------------------------------------
// 2) Touch link from both remotes. In Host mode, remote2 needs to send its
// scan request first, followed by a short delay before remote1 sends its
// scan request, otherwise it will sneak in a scan response to remote1.
send("light", "plugin zll-commissioning disable");
send("remote2", "plugin zll-commissioning enable");
send("remote2", "plugin zll-commissioning link");
networkWait(1000);
send("remote1", "plugin zll-commissioning link");
expect("remote2", "Touch link failed: 0x04");  // EMBER_AF_ZLL_PREEMPTED_BY_STACK
expect("remote2", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("remote2", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("remote2", timeout * 10);
expect("remote2", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("remote1") + "\\) complete", timeout * 10);
expectNetworkUp("remote1", timeout * 10);
expect("remote1", "Touch link with 0x0003 \\(\\(>\\)" + eui64("remote2") + "\\) complete", timeout * 10);

// The first remote should have split its address range and assigned half to
// the second remote. Plus, they should state themselves as ZigBee 3.0 devices
// since they have touch linked.
send("remote1", "plugin zll-commissioning status");
expect("remote1", "Bitmask: 0x00000092");  // Initiator bit now set
expect("remote1", "Free Node IDs,  Min: 0x0004, Max: 0x7FFC");
expect("remote1", "Free Group IDs, Min: 0x0061, Max: 0x7FAE");
expect("remote1", "My Group ID Min: 0x0001");
send("remote2", "plugin zll-commissioning status");
expect("remote2", "Bitmask: 0x00000092");  // Initiator bit now set
expect("remote2", "Free Node IDs,  Min: 0x7FFD, Max: 0xFFF7");
expect("remote2", "Free Group IDs, Min: 0x7FAF, Max: 0xFEFF");
expect("remote2", "My Group ID Min: 0x0041");

// Check that the light and both remotes are on the same network.
assert(panId("remote1").equals(panId("light")));
assert(extendedPanId("remote1").equals(extendedPanId("light")));
assert(channel("remote1").equals(channel("light")));
assert(panId("remote1").equals(panId("remote2")));
assert(extendedPanId("remote1").equals(extendedPanId("remote2")));
assert(channel("remote1").equals(channel("remote2")));

// Control the light from the second remote...
network.pressButton("remote2", "1");
network.releaseButton("remote2", "1");
expect("remote2", ".*Broadcasting \"on\" command");
expect("light", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 01 payload\\[\\]");
expect("light", "Light on 0x01 is now ON");

// ... and from the first remote.
network.pressButton("remote1", "0");
network.releaseButton("remote1", "0");
expect("remote1", ".*Broadcasting \"off\" command");
expect("light", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 00 payload\\[\\]");
expect("light", "Light on 0x01 is now OFF");

//-----------------------------------------------------------------------------
// 3) Take the second remote off the network and reboot the light.  When the light
// comes back, touch linking with it should still work (bug 13354).
expect("remote2", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", timeout * 10);
send("remote2", "plugin zll-commissioning disable");
reboot("light");
networkWait(5000);

// We expect a success callback, and the identify mode cancel, but no network up.
send("remote1", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("remote1", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
nexpect("remote1", "EMBER_NETWORK_UP 0x....", timeout * 10);

// remote2 should steal the light from remote1.
send("remote2", "plugin zll-commissioning enable");
send("remote2", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("remote2") + "\\) complete", timeout * 10);
expectNetworkUp("remote2", timeout * 10);
expect("remote2", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete", timeout * 10);

//-----------------------------------------------------------------------------
// 4) Make remote1 FN and touchlink it to the second light. Then check it can still touchlink
// to the NFN remote2 (EMZIGBEE-3784).
power("light2", true);
networkWait(5000);
setupEncryption();

send("light", "plugin zll-commissioning disable");
expect("remote1", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", timeout * 10);
send("remote1", "plugin zll-commissioning link");
expect("light2", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light2", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light2", timeout * 10);
expect("light2", "Touch link with 0x0001 \\(\\(>\\)" + eui64("remote1") + "\\) complete", timeout * 10);
expectNetworkUp("remote1", timeout * 10);
expect("remote1", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light2") + "\\) complete", timeout * 10);

send("light2", "plugin zll-commissioning disable");
send("remote1", "plugin zll-commissioning link");
expect("remote2", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("remote2", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("remote2", timeout * 10);
expect("remote2", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("remote1") + "\\) complete", timeout * 10);
expectNetworkUp("remote1", timeout * 10);
expect("remote1", "Touch link with 0x0003 \\(\\(>\\)" + eui64("remote2") + "\\) complete", timeout * 10);

// Control the light from the second remote...
network.pressButton("remote2", "1");
network.releaseButton("remote2", "1");
expect("remote2", ".*Broadcasting \"on\" command");
expect("light2", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 01 payload\\[\\]");
expect("light2", "Light on 0x01 is now ON");

// ...and back off.
network.pressButton("remote2", "0");
network.releaseButton("remote2", "0");
expect("remote2", ".*Broadcasting \"off\" command");
expect("light2", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 00 payload\\[\\]");
expect("light2", "Light on 0x01 is now OFF");

//-----------------------------------------------------------------------------
// 5) Take light2 down, reset remote1, and check that the orphaned 
// remote1 can still touchlink the first light (EMZIGBEE-2013)

// Kill the second remote, to keep the output clean.
power("remote2", false);

expect("light2", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", timeout * 10);
power("light2", false);
send("remote1", "reset");

expect("remote1", "Max move limit reached.*", 60000); // no parent!
send("light", "reset");  // make sure the radio is on and touchlinking is enabled

send("remote1", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);

// Make sure the initiator sends a join request, rather than a start request (EMZIGBEE-4186)
expect("remote1", "Sending join request to target");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("remote1", timeout * 10);

// The light is allocated a new node id.
expect("remote1", "Touch link with 0x0004 \\(\\(>\\)" + eui64("light") + "\\) complete", timeout * 10);

// Control the light...
network.pressButton("remote1", "1");
network.releaseButton("remote1", "1");
expect("remote1", ".*Broadcasting \"on\" command");
expect("light", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 01 payload\\[\\]");
expect("light", "Light on 0x01 is now ON");

// ...and back off.
network.pressButton("remote1", "0");
network.releaseButton("remote1", "0");
expect("remote1", ".*Broadcasting \"off\" command");
expect("light", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 00 payload\\[\\]");
expect("light", "Light on 0x01 is now OFF");

//-----------------------------------------------------------------------------
// 6) Check that we can handle collisions between rejoining and touchlinking (EMZIGEE-1910)
// Case 1 - Immediately after scheduling the first rejoin attempt.
expect("light", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", timeout * 10);
send("light", "reset");  // make sure the radio is on

// The rejoins are forced to be secure, but fail because the light is down.
// The touchlink fails, because the remote is scanning for the first rejoin attempt.
expect("remote1", "Schedule move nwk 0: 0", 50000);  // allow for host
expect("remote1", "plugin zll-commissioning link", "Error: Touch linking failed: could not start scan: 0x3D");
expect("remote1", "A node on a distributed network cannot do a TC rejoin.", timeout * 10);
expect("remote1", "Max move limit reached nwk 0: 3", timeout * 10);

// Case 2 - Immediately after scheduling the second rejoin attempt.
send("remote1", "plugin zll-commissioning link");
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("remote1") + "\\) complete", timeout * 10);
expectNetworkUp("remote1", timeout * 10);
expect("remote1", "Touch link with 0x0005 \\(\\(>\\)" + eui64("light") + "\\) complete", timeout * 10);

expect("light", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", timeout * 10);
send("light", "reset");  // make sure the radio is on

// The scheduled rejoin never happens, but the touchlink succeeds.
expect("remote1", "Schedule move nwk 0: 1", 50000);
send("remote1", "plugin zll-commissioning link");
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("remote1") + "\\) complete", timeout * 10);
expectNetworkUp("remote1", timeout * 10);
expect("remote1", "Touch link with 0x0006 \\(\\(>\\)" + eui64("light") + "\\) complete", timeout * 10);
networkWait(5000);

// Case 3 - A few seconds after scheduling the second rejoin attempt.
expect("light", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", timeout * 10);
send("light", "reset");  // make sure the radio is on

// The rejoin gets rescheduled, but the touchlink succeeds.
expect("remote1", "Schedule move nwk 0: 1", 50000);  // allow for host
networkWait(5000);
expect("remote1", "plugin zll-commissioning link", "Rescheduling move due to ZLL operation.", timeout * 5);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("remote1") + "\\) complete", timeout * 10);
expectNetworkUp("remote1", timeout * 10);
expect("remote1", "Touch link with 0x0007 \\(\\(>\\)" + eui64("light") + "\\) complete", timeout * 10);
networkWait(5000);

// Control the light...
network.pressButton("remote1", "1");
network.releaseButton("remote1", "1");
expect("remote1", ".*Broadcasting \"on\" command");
expect("light", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 01 payload\\[\\]");
expect("light", "Light on 0x01 is now ON");

// ...and back off.
network.pressButton("remote1", "0");
network.releaseButton("remote1", "0");
expect("remote1", ".*Broadcasting \"off\" command");
expect("light", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 00 payload\\[\\]");
expect("light", "Light on 0x01 is now OFF");

//-----------------------------------------------------------------------------
// 7) Check channel agility - move the target to a non-touchlink-primary channel
// (so we know it's actually different) while the initiator is powered off.
power("remote1", false);
expect("light", "network change-channel 12", "Changing to channel 12: 0x00");
networkWait(10000);
power("remote1", true);

// Expect a secure rejoin on the second attempt.
expect("remote1", "Schedule move nwk 0: 0", 50000);  // allow for host
expect("remote1", "Schedule move nwk 0: 1");

// We just use the TC join handler to check that the rejoin is secure - we don't expect
// it to do anything, of course.

expect("light", "Trust Center Join Handler: status = secured rejoin, decision = no action \\(03\\), shortid 0x0001", 50000);
networkWait(2000);  // give some time to rejoin 'remote1'.
assertSameNetwork("light", "remote1");


// Control the light...
network.pressButton("remote1", "1");
network.releaseButton("remote1", "1");
expect("remote1", ".*Broadcasting \"on\" command");
expect("light", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 01 payload\\[\\]");
expect("light", "Light on 0x01 is now ON");

// ...and back off.
network.pressButton("remote1", "0");
network.releaseButton("remote1", "0");
expect("remote1", ".*Broadcasting \"off\" command");
expect("light", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 00 payload\\[\\]");
expect("light", "Light on 0x01 is now OFF");
