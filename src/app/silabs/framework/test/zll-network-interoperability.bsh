import com.ember.peek.SimulatedNetwork;

source("util.bsh");

if (runArgument.runUsingMultihop) {
  std.print("****TODO: Fix for multi-hop****");
  return;
}

// Create two nodes in the network.
SimulatedNetwork network = createNetwork();
String[] devices = new String[]{"zll-light1", "zll-light2", "zll-remote1", "zll-remote2", "ha-light", "ha-switch"};

String[] socImages = new String[] {
  "build/af-test-apps/ZllColorLight-simulation/ZllColorLight",
  "build/af-test-apps/ZllColorLight-simulation/ZllColorLight",
  "build/af-test-apps/ZllColorSceneRemote-simulation/ZllColorSceneRemote",
  "build/af-test-apps/ZllColorSceneRemote-simulation/ZllColorSceneRemote",
  "build/af-test-apps/HaLight-simulation/HaLight",
  "build/af-test-apps/HaSwitch-simulation/HaSwitch",
};
String[] hostImages = new String[] {
  "build/af-test-apps/ZllColorLight-simulation-ezsp/ZllColorLight",
  "build/af-test-apps/ZllColorLight-simulation-ezsp/ZllColorLight",
  "build/af-test-apps/ZllColorSceneRemote-simulation-ezsp/ZllColorSceneRemote",
  "build/af-test-apps/ZllColorSceneRemote-simulation-ezsp/ZllColorSceneRemote",
  "build/af-test-apps/HaLight-simulation-ezsp/HaLight",
  "build/af-test-apps/HaSwitch-simulation-ezsp/HaSwitch",
};
String ncpImage = "app/ncp/sample-app/ncp-spi/simulation/build/exe/ncp-spi";

// Create network and load devices according to the runArguments provided.
addAndLoadDevices(devices, socImages, hostImages, ncpImage);
setupEncryption();

// After joining a network that was found during a scan, the Network Find and
// ZLL Commissioning plugins wait a bit to give the application time to decide
// whether it wants to stay on the network.  If the application leaves, the
// plugins will continue scanning.  Otherwise, they will clean up their state
// machines and the form and join state machine.  So that we do not trigger the
// automatic continuation of the scan, wait for two minutes (the default
// timeout is one minute) after a joinable scan.
final int JOINABLE_SCAN_TIMEOUT = 120000;

//------------------------------------------------------------
// Form a network on the first ZLL light and touch link from the first ZLL
// remote.
startZllNetwork("zll-light1", "11", "0", "0x1234", timeout * 10);

send("zll-light2", "plugin zll-commissioning disable");
send("zll-remote2", "plugin zll-commissioning disable");

send("zll-remote1", "plugin zll-commissioning link");
expect("zll-light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("zll-light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("zll-light1", timeout * 10);
expect("zll-light1", "Touch link with 0x0001 \\(\\(>\\)" + eui64("zll-remote1") + "\\) complete");
expectNetworkUp("zll-remote1", timeout * 10);
expect("zll-remote1", "Touch link with 0x0002 \\(\\(>\\)" + eui64("zll-light1") + "\\) complete");
expect("zll-light1", "keys print", ".*D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF.*");
expect("zll-remote1", "keys print", ".*D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF.*");

// We may not be on channel 11 after the touchlink.
String zllChannel = channel("zll-light1");
String zllPanId = panId("zll-light1");
String zllExtendedPanId = extendedPanId("zll-light1");

// Permit joining on the first ZLL light and attempt to join from the second
// ZLL light.  But, first, set the preconfigured key from the command line on
// ZLL device.  By default, it will use the well-known key.
permitJoin("zll-light1", true);
expect("zll-light2", "changekey link {D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF}", "set key");
zllJoin("zll-light2", timeout * 10);
expect("zll-light2", "keys print", ".*D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF.*");
networkWait(JOINABLE_SCAN_TIMEOUT);

// Attempt to join from the HA light.  This will fail because the preconfigured
// keys are incompatible.
send("ha-light", "network find joinable");
expect("ha-light", "Joining on ch " + zllChannel + ", panId 0x....", timeout * 10);
expect("ha-light", "EMBER_JOIN_FAILED", timeout * 10);
expect("ha-light", "Network find complete \\(scan error\\).", timeout * 10);

//------------------------------------------------------------
// Reset the ZLL devices so we can start over.
expect("zll-remote1", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", timeout * 10);
expect("zll-light1", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", timeout * 10);
expect("zll-light2", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN");

// Using an HA light, start a centralized network on a primary channel.
send("ha-light", "network form 19 1 0xABCD");
permitJoin("ha-light", true);

// The ZLL remote should not find the HA light using a touch link.
// (the second remote is already disabled at this point)
send("zll-light1", "plugin zll-commissioning disable");
send("zll-light2", "plugin zll-commissioning disable");

// We need a short delay here after the disable for the SoC test.
networkWait(500);
send("zll-remote1", "plugin zll-commissioning link");

// We should get a 'no networks found' status.
expect("zll-remote1", "Touch link failed: 0x03", timeout * 10);

// Start up a ZLL light.  The light should find the HA network and join to it.
zllJoin("zll-light1", timeout * 10);
expect("zll-light1", "keys print", ".*5A 69 67 42 65 65 41 6C  6C 69 61 6E 63 65 30 39.*");
assertSameNetwork("ha-light", "zll-light1");
networkWait(JOINABLE_SCAN_TIMEOUT);

// The ZLL light should now be non factory new, not address assignment capable,
// and it should not have any free network or group addresses. Since the
// zll-light1 joined a classical ZigBee network, it has its profile interop
// state set.
send("zll-light1", "plugin zll-commissioning status");
expect("zll-light1", "Bitmask: 0x00000180");
expect("zll-light1", "Free Node IDs,  Min: 0x0000, Max: 0x0000");
expect("zll-light1", "Free Group IDs, Min: 0x0000, Max: 0x0000");
expect("zll-light1", "My Group ID Min: 0x0000");
networkWait(timeout);

// Join an HA switch to the HA network and make sure it can control the HA and
// ZLL lights.
networkFindJoinable("ha-switch", timeout);
assertSameNetwork("ha-light", "ha-switch");
networkWait(timeout);
send("ha-switch", "zcl on-off toggle");
send("ha-switch", "send 0xFFFF 0x01 0xFF");
assert(network.expect(new String[]{"ha-light", "zll-light1"}, port, "Light on 0x0[16] is now ON").length == 0);
networkWait(JOINABLE_SCAN_TIMEOUT);

// Join a ZLL remote to the HA network.
zllJoin("zll-remote1",timeout * 10);
expect("zll-remote1", "keys print", ".*5A 69 67 42 65 65 41 6C  6C 69 61 6E 63 65 30 39.*");
assertSameNetwork("ha-light", "zll-remote1");
networkWait(JOINABLE_SCAN_TIMEOUT);

// Like the ZLL light, the ZLL remote should be non factory new.  It is address
// assignment capable, but it should not have any free network or group
// addresses. It should state itself as a ZigBee 3.0 device since we tried
// touch linking with it earlier.
send("zll-remote1", "plugin zll-commissioning status");
expect("zll-remote1", "Bitmask: 0x00000192");  // initiator bit set
expect("zll-remote1", "Free Node IDs,  Min: 0x0000, Max: 0x0000");
expect("zll-remote1", "Free Group IDs, Min: 0x0000, Max: 0x0000");
expect("zll-remote1", "My Group ID Min: 0x0000");
networkWait(timeout);

// Make sure the ZLL remote can control the HA and ZLL lights.
buttonPress("zll-remote1",
            0,
            null,                               // press button expect
            ".*Broadcasting \"off\" command");  // release button expect

assert(network.expect(new String[]{"ha-light", "zll-light1"}, port, "Light on 0x0[16] is now OFF").length == 0);
buttonPress("zll-remote1",
            1,
            null,                             // press button expect
            ".*Broadcasting \"on\" command"); // release button expect

assert(network.expect(new String[]{"ha-light", "zll-light1"}, port, "Light on 0x0[16] is now ON").length == 0);

// Touch link again from the ZLL remote.  Because the devices are both on the
// same HA network, with the same network id, no network action should occur.
// The ZLL remote should just get the node id of the target.
String nid = nodeId("zll-light1");
send("zll-light1", "plugin zll-commissioning enable");
send("zll-remote1", "plugin zll-commissioning link");
expect("zll-remote1", "Touch link with 0x.... \\(\\(>\\)" + eui64("zll-light1") + "\\) complete", timeout * 10);
nexpect("zll-remote1", "EMBER_NETWORK_UP 0x....", timeout * 10);

// Using different channels, touch link again.  Because the ZLL remote is on a
// centralized network, it is not allowed to touch link with with factory new ZLL
// devices or ZLL devices on other networks.  It will therefore ignore the ZLL
// light.
send("zll-light1", "plugin zll-commissioning disable");
send("zll-light2", "plugin zll-commissioning enable");
expect("zll-remote1", "plugin zll-commissioning channel 12", "Primary channels: 12 \\(0x00001000\\)");

// NOTE - allow for CLI prompt
expect("zll-light2", "plugin zll-commissioning channel 12", ".*Primary channels: 12 \\(0x00001000\\)");
startZllNetwork("zll-light2", "12", "0", "0x5678", timeout * 10);

// extra delay to ensure that light1 is properly up, because the other zll devices
// will now get in the way. (IOW, if you comment this line out the touchlink fails)
networkWait(5000);

send("zll-remote1", "plugin zll-commissioning link");
expect("zll-remote1", "Touch link failed: 0x03", timeout * 10);
expect("zll-light2", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN");

// Repeat the same test with a ZLL remote as the potential target.  Again, it
// will be ignored.
send("zll-light2", "plugin zll-commissioning disable");
send("zll-remote2", "plugin zll-commissioning enable");

expect("zll-remote1", "plugin zll-commissioning channel 12", "Primary channels: 12 \\(0x00001000\\)");

// NOTE - allow for CLI prompt (why me??)
expect("zll-remote2", "plugin zll-commissioning channel 12", ".*Primary channels: 12 \\(0x00001000\\)");
network.send(new String[]{"zll-remote1", "zll-remote2"}, port, "plugin zll-commissioning link");
expect("zll-remote2", "Touch link failed: 0x04");
expect("zll-remote1", "Touch link failed: 0x03", timeout * 10);

//------------------------------------------------------------
// Reset each of the joined nodes and make sure they stay on the same network.
reboot("ha-switch");
reboot("ha-light");
reboot("zll-remote1");
reboot("zll-light1");
networkWait(1000); // Work around yet another beacon collision
assertSameNetwork("ha-light","ha-switch");
assertSameNetwork("ha-light","zll-remote1");
assertSameNetwork("ha-light","zll-light1");
networkWait(timeout);

// NOTE - touchlinking is at this point enabled for all ZLL devices
// except zll-light2

// Reset the first ZLL remote.  This will cause it to leave the HA network.
expect("zll-remote1", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN");
networkWait(timeout * 10);

// Try touch linking again from the first ZLL remote.  It should find a ZLL
// light on the HA network, steal it, and form a new ZLL network.  On the new
// network, the ZLL remote and the ZLL light should be using tree addressing
// and have the first two addresses.
String haChannel = channel("ha-light");
expect("zll-remote1", "plugin zll-commissioning channel " + haChannel, "Primary channels: " + haChannel + " \\(" + channelMask(haChannel) + "\\)");
send("zll-remote1", "plugin zll-commissioning link");
expect("zll-light1", ".*RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("zll-light1", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("zll-light1", timeout * 10);
expect("zll-light1", "Touch link with 0x0001 \\(\\(>\\)" + eui64("zll-remote1") + "\\) complete");
expectNetworkUp("zll-remote1", timeout * 10);
expect("zll-remote1", "Touch link with 0x0002 \\(\\(>\\)" + eui64("zll-light1") + "\\) complete");
expect("zll-light1", "keys print", ".*D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF.*");
expect("zll-remote1", "keys print", ".*D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF.*");
zllChannel = channel("zll-remote1");
zllPanId = panId("zll-remote1");
zllExtendedPanId = extendedPanId("zll-remote1");
assert(nodeId("zll-remote1").equals("0x0001"));
assert(nodeId("zll-light1").equals("0x0002"));
assert(channel("zll-light1").equals(zllChannel));
assert(panId("zll-light1").equals(zllPanId));
assert(extendedPanId("zll-light1").equals(zllExtendedPanId));
networkWait(timeout);

// On the ZLL network, the ZLL remote should now have a valid range of free
// network and group addresses.  The ZLL light should look the same as before
// because it is not address assignment capable. The remote should
// say that it is a ZigBee 3.0 device since it has touch linked. Also, the
// light should say that it is a ZigBee 3.0 device because it set its profile
// interop state when it joined the classical ZigBee network.
send("zll-remote1", "plugin zll-commissioning status");
expect("zll-remote1", "Bitmask: 0x00000092");  // initiator bit set
expect("zll-remote1", "Free Node IDs,  Min: 0x0003, Max: 0xFFF7");
expect("zll-remote1", "Free Group IDs, Min: 0x0041, Max: 0xFEFF");
expect("zll-remote1", "My Group ID Min: 0x0001");
networkWait(timeout);
send("zll-light1", "plugin zll-commissioning status");
expect("zll-light1", "Bitmask: 0x00000080");
expect("zll-light1", "Free Node IDs,  Min: 0x0000, Max: 0x0000");
expect("zll-light1", "Free Group IDs, Min: 0x0000, Max: 0x0000");
expect("zll-light1", "My Group ID Min: 0x0021");
networkWait(timeout);

// Try the toggling the lights again from the HA switch.  This should work for
// the HA light and the second ZLL light, but fail for the first ZLL light
// because it is now on a different network.
send("ha-switch", "zcl on-off toggle");
send("ha-switch", "send 0xFFFF 0x01 0xFF");
expect("ha-light", "Light on 0x06 is now ON");

// Use the buttons on the first ZLL remote to control the first ZLL light.
buttonPress("zll-remote1",
            1,
            null,                                // press button expect
            ".*Broadcasting \"on\" command");    // release button expect
expect("zll-light1", "Light on 0x01 is now ON");

buttonPress("zll-remote1",
            0,
            null,                               // press button expect
            ".*Broadcasting \"off\" command");  // release button expect
expect("zll-light1", "Light on 0x01 is now OFF");

// Reset the ZLL devices and make sure they stay on the same network.
reboot("zll-remote1");
reboot("zll-light1");
assert(nodeId("zll-remote1").equals("0x0001"));
assert(nodeId("zll-light1").equals("0x0002"));
assert(channel("zll-remote1").equals(zllChannel));
assert(channel("zll-light1").equals(zllChannel));
assert(panId("zll-remote1").equals(zllPanId));
assert(panId("zll-light1").equals(zllPanId));
assert(extendedPanId("zll-remote1").equals(zllExtendedPanId));
assert(extendedPanId("zll-light1").equals(zllExtendedPanId));
networkWait(timeout);

// Turn on permit joining on the first ZLL light and then have all the devices
// on the HA network leave and join the new ZLL network.  Joining from the HA
// devices will fail (due the mismatched pre-configured keys), but it will work
// for the ZLL devices.
// (Note that zll-remote2 is not joined at this point, due to the changes
// in pre-emption handling.)
permitJoin("zll-light1", true);
expect("ha-light", "network leave", ".*EMBER_NETWORK_DOWN", timeout * 10);
expect("ha-switch", "network leave", ".*EMBER_NETWORK_DOWN", timeout * 10);
nexpect("zll-remote2", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN");

// This delay needs to be long enough to cover the entire rejoin process,
// otherwise we will get 'beacon collisions'
networkWait(timeout*20);

// Start with the HA devices.
send("ha-light", "network find joinable");
expect("ha-light", "Joining on ch " + zllChannel + ", panId " + zllPanId, timeout * 10);
expect("ha-light", "EMBER_JOIN_FAILED", timeout * 10);
networkWait(1000); // Delay added to work around beacon *request* collision; that's a new one!
send("ha-switch", "network find joinable");
expect("ha-switch", "Joining on ch " + zllChannel + ", panId " + zllPanId, timeout * 10);
expect("ha-switch", "EMBER_JOIN_FAILED", timeout * 10);
expect("ha-switch", "Network find complete \\(scan error\\).", timeout * 10);
expect("zll-light2", "plugin zll-commissioning mask 0", ".*Primary channels: 11, 15, 20, 25 \\(0x02108800\\)");

// Now try the ZLL devices.
networkWait(JOINABLE_SCAN_TIMEOUT);  // Wait to avoid beacon collisions
zllJoin("zll-light2", timeout * 10);
expect("zll-light2", "keys print", ".*D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF.*");
assert(channel("zll-light2").equals(zllChannel));
assert(panId("zll-light2").equals(zllPanId));
assert(extendedPanId("zll-light2").equals(zllExtendedPanId));
networkWait(JOINABLE_SCAN_TIMEOUT);
expect("zll-remote2", "changekey link {D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF}", ".*set key");
expect("zll-remote2", "plugin zll-commissioning mask 0", ".*Primary channels: 11, 15, 20, 25 \\(0x02108800\\)");
zllJoin("zll-remote2", timeout * 10);
expect("zll-remote2", "keys print", ".*D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF.*");
assert(channel("zll-remote2").equals(zllChannel));
assert(panId("zll-remote2").equals(zllPanId));
assert(extendedPanId("zll-remote2").equals(zllExtendedPanId));
networkWait(JOINABLE_SCAN_TIMEOUT);

// Use the buttons on the ZLL remotes to control the ZLL lights.
buttonPress("zll-remote2", 1);
expect("zll-remote2", ".*Broadcasting \"on\" command");
assert(network.expect(new String[]{"zll-light1", "zll-light2"}, port, "Light on 0x01 is now ON").length == 0);
networkWait(timeout);
buttonPress("zll-remote1", 0);
expect("zll-remote1", "Broadcasting \"off\" command");
assert(network.expect(new String[]{"zll-light1", "zll-light2"}, port, "Light on 0x01 is now OFF").length == 0);
networkWait(timeout);

// Bug 14061: When ZLL end devices join non-ZLL networks, they should not have
// free network or group addresses.  Form a new HA network with the HA light
// and have the first ZLL remote join to it.  After the join, the remote should
// be non factory new.  It is address assignment capable, but it should not
// have any free network or group addresses.
expect("zll-remote1", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN");
networkFindUnused("ha-light", timeout * 10);
permitJoin("ha-light", true);
expect("zll-remote1", "changekey link {5A 69 67 42 65 65 41 6C  6C 69 61 6E 63 65 30 39}", "set key");
//The following beacon request seems to be getting squashed in some cases in the host test. .All 
// three attempts at sending out the beacon request fail to be heard by all other radios in the network.
// Since the remote joined a classical ZigBee network, it states itself as a
// ZigBee 3.0 device.
networkWait(10000);
zllJoin("zll-remote1", timeout * 10);
send("zll-remote1", "plugin zll-commissioning status");
expect("zll-remote1", "Bitmask: 0x00000182");  // initiator bit clear
expect("zll-remote1", "Free Node IDs,  Min: 0x0000, Max: 0x0000");
expect("zll-remote1", "Free Group IDs, Min: 0x0000, Max: 0x0000");
expect("zll-remote1", "My Group ID Min: 0x0000");
