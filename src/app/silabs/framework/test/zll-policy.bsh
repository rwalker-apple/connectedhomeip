import com.ember.peek.SimulatedNetwork;

source("util.bsh");

if (runArgument.runUsingMultihop) {
  std.print("****TODO: Fix for multi-hop****");
  return;
} 

// Create nodes in the network.
SimulatedNetwork network = createNetwork();
String[] devices = new String[]{"remote", "switch", "light", "bridge", "secure-light"};

// Note, ZllOnOffSwitch is a client-only initiator. ZllOnOffLight is built
// with stealing disabled at compile time, so it can never be stolen.
String[] socImages = new String[] {
  "build/af-test-apps/ZllColorSceneRemote-simulation/ZllColorSceneRemote",
  "build/af-test-apps/ZllOnOffSwitch-simulation/ZllOnOffSwitch",
  "build/af-test-apps/ZllColorLight-simulation/ZllColorLight",
  "build/af-test-apps/ZllControlBridgeZ3-simulation/ZllControlBridgeZ3",
  "build/af-test-apps/ZllOnOffLight-simulation/ZllOnOffLight",
};
String[] hostImages = new String[] {
  "build/af-test-apps/ZllColorSceneRemote-simulation-ezsp/ZllColorSceneRemote",
  "build/af-test-apps/ZllOnOffSwitch-simulation-ezsp/ZllOnOffSwitch",
  "build/af-test-apps/ZllColorLight-simulation-ezsp/ZllColorLight",
  "build/af-test-apps/ZllControlBridgeZ3-simulation-ezsp/ZllControlBridgeZ3",
  "build/af-test-apps/ZllOnOffLight-simulation-ezsp/ZllOnOffLight",
};
String ncpImage = "app/ncp/sample-app/ncp-spi/simulation/build/exe/ncp-spi";

// Create network and load devices according to the runArguments provided.
addAndLoadDevices(devices, socImages, hostImages, ncpImage);
setupEncryption();

//--------------------------------------------------
dbg.println("\n***Scenario 1: touch link remote to light\n");

// Network "A" will be on channel 20, with "light" and "remote"
send("light", "plugin zll-commissioning channel 20");
startZllNetwork("light", "20", "0", "0x1234", timeout * 10);
String ZllChannel = channel("light");
expect("remote", "plugin zll-commissioning channel " + ZllChannel, "Primary channels: " + ZllChannel + " \\(" + channelMask(ZllChannel) + "\\)");
send("remote", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("remote") + "\\) complete", timeout * 10);
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete", timeout * 10);

dbg.println("\n***Make sure remote is communicating to light\n");
network.pressButton("remote", "1");
network.releaseButton("remote", "1");
expect("remote", ".*Broadcasting \"on\" command");
expect("light", "Light on 0x01 is now ON");

network.pressButton("remote", "0");
network.releaseButton("remote", "0");
expect("remote", ".*Broadcasting \"off\" command");
expect("light", "Light on 0x01 is now OFF");

//--------------------------------------------------
dbg.println("\n***Scenario 2: touch link switch to bridge and secure-light\n");

// Network "B" will be on channel 25, with "switch", "bridge", and "secure-light"
send("bridge", "plugin zll-commissioning channel 25");
startZllNetwork("bridge", "25", "0", "0x5678", timeout * 10);
String ZllChannel = channel("bridge");
expect("switch", "plugin zll-commissioning channel " + ZllChannel, "Primary channels: " + ZllChannel + " \\(" + channelMask(ZllChannel) + "\\)");

send("switch", "plugin zll-commissioning link");
expect("bridge", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("bridge", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("bridge", timeout * 10);
expect("bridge", "Touch link with 0x0001 \\(\\(>\\)" + eui64("switch") + "\\) complete", timeout * 10);
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0002 \\(\\(>\\)" + eui64("bridge") + "\\) complete", timeout * 10);

dbg.println("switch channel = " + channel("switch"));
networkWait(1000);

// In this script, we will power off devices we don't wish to link to, rather than using 
// plugin zll-commissioning disable, since that's what we're supposed to be testing...
power("bridge", false); // "switch" will have to change parent when it rejoins

// We can't use a 'commissioning network' with secure-light now, as there is no
// difference between a real nwk and 'comm' nwk as far as stealing is concerned.
send("secure-light", "plugin zll-commissioning channel 25");
send("switch", "plugin zll-commissioning link");
expect("secure-light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("secure-light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("secure-light", timeout * 10);
expect("secure-light", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("switch") + "\\) complete", timeout * 10);
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0003 \\(\\(>\\)" + eui64("secure-light") + "\\) complete", timeout * 10);

power("bridge", true);
networkWait(5000);
setupEncryption();

dbg.println("\n***make sure switch is communicating to the other devices by reading basic cluster attr\n");
String nIdbridge = findNodeByName("bridge").nodeIdHex;

// SoC currently needs an extra delay, to allow the parent announce procedure to complete.
if (!runArgument.runUsingHostApps) {
  networkWait(3000);
}

send("switch", "zcl global read 0x0000 0x0000");
send("switch", "send " + nIdbridge + " 1 1");
expect("bridge", "T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x0000 \\(Basic\\) FC 00 seq [0-9a-fA-F]{2} cmd 00 payload\\[00 00 \\]");
expect("switch", "T[0-9a-fA-F]{8}:RX len 8, ep 01, clus 0x0000 \\(Basic\\) FC 08 seq [0-9a-fA-F]{2} cmd 01 payload\\[00 00 00 20 03 \\]");
expect("bridge", "T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x0000 \\(Basic\\) FC 00 seq [0-9a-fA-F]{2} cmd 0B payload\\[01 00 \\]");

String nIdbridge = findNodeByName("secure-light").nodeIdHex;
send("switch", "zcl global read 0x0000 0x0000");
send("switch", "send " + nIdbridge + " 1 1");
expect("secure-light", "T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x0000 \\(Basic\\) FC 00 seq [0-9a-fA-F]{2} cmd 00 payload\\[00 00 \\]");
expect("switch", "T[0-9a-fA-F]{8}:RX len 8, ep 01, clus 0x0000 \\(Basic\\) FC 08 seq [0-9a-fA-F]{2} cmd 01 payload\\[00 00 00 20 03 \\]");
expect("secure-light", "T[0-9a-fA-F]{8}:RX len 5, ep 01, clus 0x0000 \\(Basic\\) FC 00 seq [0-9a-fA-F]{2} cmd 0B payload\\[01 00 \\]");

//--------------------------------------------------
dbg.println("\n***Scenario 3: try to steal the two server devices on the second network\n");

// The secure-light is also potentially stealable now.
power("secure-light", false);

send("remote", "plugin zll-commissioning channel 25");
send("remote", "plugin zll-commissioning link");
expect("bridge", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("bridge", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("bridge", timeout * 10);
expect("bridge", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("remote") + "\\) complete", timeout * 10);
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0x0003 \\(\\(>\\)" + eui64("bridge") + "\\) complete", timeout * 10);

// Compare the network params to make sure bridge is stolen successfully.
zllChannel = channel("remote");
zllPanId = panId("remote");
zllExtendedPanId = extendedPanId("remote");
assert(channel("bridge").equals(zllChannel));
assert(panId("bridge").equals(zllPanId));
assert(extendedPanId("bridge").equals(zllExtendedPanId));
networkWait(timeout);

dbg.println("\n***Make sure remote is still communicating to light\n");
network.pressButton("remote", "1");
network.releaseButton("remote", "1");
expect("remote", ".*Broadcasting \"on\" command");
expect("light", "Light on 0x01 is now ON");

network.pressButton("remote", "0");
network.releaseButton("remote", "0");
expect("remote", ".*Broadcasting \"off\" command");
expect("light", "Light on 0x01 is now OFF");

// Now try to steal "secure-light" from the second network.
power("secure-light", true);
networkWait(5000);
setupEncryption();

// The touchlink will fail, since stealing is disabled on "secure-light"
send("remote", "plugin zll-commissioning link");
expect("remote", "Touch link failed: 0x02", timeout * 10);

// Re-enable, and try again. It will fail again, since stealing was
// disabled at compile-time, and cannot be re-enabled.
send("secure-light", "plugin zll-commissioning enable");
send("remote", "plugin zll-commissioning link");
expect("remote", "Touch link failed: 0x02", timeout * 10);

//--------------------------------------------------
dbg.println("\n***Scenario 4: Runtime restrict stealing, when switch tries to steal the bridge back\n");

power("remote", false);
power("light", false);
power("secure-light", false); // not required again

send("bridge", "plugin zll-commissioning notouchlink-nfn");
send("switch", "plugin zll-commissioning channel 20");
expect("switch", "plugin zll-commissioning link", "EMBER_JOIN_FAILED", timeout*10);

// remote and bridge still should be in same network if bridge has successfuly rejected the stealing/join request.
power("remote", true);
networkWait(5000);
setupEncryption();

zllChannel = channel("remote");
zllPanId = panId("remote");
zllExtendedPanId = extendedPanId("remote");
assert(channel("bridge").equals(zllChannel));
assert(panId("bridge").equals(zllPanId));
assert(extendedPanId("bridge").equals(zllExtendedPanId));
networkWait(timeout*10);  // avoid beacon collision

// We'll repeat the link to check that the remote handled the touchlink failure correctly.
power("remote", false);
expect("switch", "plugin zll-commissioning link", "EMBER_JOIN_FAILED", timeout*10);
assert(channel("bridge").equals(zllChannel));
assert(panId("bridge").equals(zllPanId));
assert(extendedPanId("bridge").equals(zllExtendedPanId));
networkWait(timeout*10);  // avoid beacon collision

// Now re-enable stealing at the bridge and repeat.
send("bridge", "plugin zll-commissioning enable");
send("switch", "plugin zll-commissioning link");

expect("bridge", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("bridge", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expect("bridge", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("switch") + "\\) complete", timeout * 10);
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x000. \\(\\(>\\)" + eui64("bridge") + "\\) complete", timeout * 10);

// Compare the network params to make sure bridge is stolen successfully.
zllChannel = channel("switch");
zllPanId = panId("switch");
zllExtendedPanId = extendedPanId("switch");
assert(channel("bridge").equals(zllChannel));
assert(panId("bridge").equals(zllPanId));
assert(extendedPanId("bridge").equals(zllExtendedPanId));
networkWait(timeout);

//--------------------------------------------------
dbg.println("\n***Scenario 5: Runtime restrict stealing, but with a factory new initiator");

send("remote", "plugin zll-commissioning disable"); // remote is target-enabled

String zllChannel = channel("bridge");

// Touchlink policy is now reset on a commissioning reset.
expect("switch", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", timeout * 10);
send("switch", "plugin zll-commissioning channel " + zllChannel);
send("bridge", "plugin zll-commissioning notouchlink-nfn");
expect("switch", "plugin zll-commissioning link", "EMBER_JOIN_FAILED", timeout*10);

// The bridge should still be in its old network if it successfuly rejected the join request.
assert(channel("bridge").equals(zllChannel));
assert(panId("bridge").equals(zllPanId));
assert(extendedPanId("bridge").equals(zllExtendedPanId));
networkWait(timeout);

// We'll repeat the link to check that the remote handled the touchlink failure correctly.
expect("switch", "plugin zll-commissioning link", "EMBER_JOIN_FAILED", timeout*10);
assert(channel("bridge").equals(zllChannel));
assert(panId("bridge").equals(zllPanId));
assert(extendedPanId("bridge").equals(zllExtendedPanId));
networkWait(timeout*10);

// Now re-enable stealing at the bridge and repeat.
send("bridge", "plugin zll-commissioning enable");
send("switch", "plugin zll-commissioning link");

expect("bridge", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("bridge", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expect("bridge", "Touch link with 0x0001 \\(\\(>\\)" + eui64("switch") + "\\) complete", timeout * 10);
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x000. \\(\\(>\\)" + eui64("bridge") + "\\) complete", timeout * 10);

// Compare the network params to make sure bridge is stolen successfully.
zllChannel = channel("switch");
zllPanId = panId("switch");
zllExtendedPanId = extendedPanId("switch");
assert(channel("bridge").equals(zllChannel));
assert(panId("bridge").equals(zllPanId));
assert(extendedPanId("bridge").equals(zllExtendedPanId));
networkWait(timeout);

//--------------------------------------------------
dbg.println("\n***Scenario 6: Reset bridge to factory new and touchlink with switch");

// Note, "bridge" is not really FN by the Zigbee 3.0 definition, but uses emAfZllFormNetwork
// to form a 'commissioning network', but it is still subject to stealing policy.

// Start off with stealing disabled at bridge.
send("bridge", "plugin zll-commissioning notouchlink-nfn");
expect("bridge", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", timeout * 10);
send("bridge", "plugin zll-commissioning channel 15");
startZllNetwork("bridge", "15", "0", "0x2676", timeout * 10);
String ZllChannel = channel("bridge");
expect("switch", "plugin zll-commissioning channel " + ZllChannel, ".*Primary channels: " + ZllChannel + " \\(" + channelMask(ZllChannel) + "\\)");

// Touchlink policy is now reset on a commissioning reset.
send("switch", "plugin zll-commissioning link");
expect("bridge", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("bridge", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expect("bridge", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("switch") + "\\) complete", timeout * 10);
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x000. \\(\\(>\\)" + eui64("bridge") + "\\) complete", timeout * 10);

// Compare the network params to make sure bridge is stolen successfully.
zllChannel = channel("switch");
zllPanId = panId("switch");
zllExtendedPanId = extendedPanId("switch");
assert(channel("bridge").equals(zllChannel));
assert(panId("bridge").equals(zllPanId));
assert(extendedPanId("bridge").equals(zllExtendedPanId));
networkWait(timeout);

//--------------------------------------------------
dbg.println("\n***Scenario 7: Attempt to touchlink client-only initiator, switch");

power("remote", true);
networkWait(5000);
setupEncryption();

// Ensure remote is able to receive scan responses.
send("remote", "plugin zll-commissioning enable");
send("bridge", "plugin zll-commissioning disable");
send("remote", "plugin zll-commissioning link");
expect("remote", "Touch link failed: 0x03", timeout * 10);

//--------------------------------------------------
dbg.println("\n***Scenario 8: Disable touchlink on initiator");

send("remote", "plugin zll-commissioning disable");
send("switch", "plugin zll-commissioning disable");
send("bridge", "plugin zll-commissioning enable");
send("remote", "plugin zll-commissioning link");
expect("remote", "Touch link failed: 0x03", timeout * 10);

//--------------------------------------------------
dbg.println("\n***Scenario 9: Repeat on client-only initiator");

send("switch", "plugin zll-commissioning link");
expect("switch", "Touch link failed: 0x03", timeout * 10);

//--------------------------------------------------
dbg.println("\n***Scenario 8: Disable touchlink on target");

send("remote", "plugin zll-commissioning enable");
send("bridge", "plugin zll-commissioning disable");
send("remote", "plugin zll-commissioning link");
expect("remote", "Touch link failed: 0x03", timeout * 10);

//--------------------------------------------------
dbg.println("\n***Scenario 9: A coordinator on a centralized network may not be touchlinked");

// Start a centralized network on a primary channel.
expect("remote", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN");
expect("bridge", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN");
expect("bridge", "plugin network-creator form 1 0xABCD 0 15", "NWK Creator: Form: 0x00");
send("bridge", "plugin zll-commissioning enable");
send("remote", "plugin zll-commissioning link");
expect("remote", "Touch link failed: 0x02", timeout * 10);




