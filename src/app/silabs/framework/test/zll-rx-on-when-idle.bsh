import com.ember.peek.SimulatedNetwork;

source("util.bsh");

if (runArgument.runUsingMultihop) {
  std.print("****TODO: Fix for multi-hop****");
  return;
} 

SimulatedNetwork network = createNetwork();
String[] devices = new String[]{"switch", "light", "remote", "sleepy-remote"};

// on-off-switch is client-only, color-scene-remote[-sleepy] is dual mode,
// color-light is server-only.
String[] socImages = new String[] {
  "build/af-test-apps/ZllOnOffSwitch-simulation/ZllOnOffSwitch",
  "build/af-test-apps/ZllColorLight-simulation/ZllColorLight",
  "build/af-test-apps/ZllColorSceneRemote-simulation/ZllColorSceneRemote",
  "build/af-test-apps/ZllColorSceneRemoteSleepy-simulation/ZllColorSceneRemoteSleepy",
};
String[] hostImages = new String[] {
  "build/af-test-apps/ZllOnOffSwitch-simulation-ezsp/ZllOnOffSwitch",
  "build/af-test-apps/ZllColorLight-simulation-ezsp/ZllColorLight",
  "build/af-test-apps/ZllColorSceneRemote-simulation-ezsp/ZllColorSceneRemote",
  "build/af-test-apps/ZllColorSceneRemoteSleepy-simulation-ezsp/ZllColorSceneRemoteSleepy",
};
String ncpImage = "app/ncp/sample-app/ncp-spi/simulation/build/exe/ncp-spi";

// Create network and load devices according to the runArguments provided.
addAndLoadDevices(devices, socImages, hostImages, ncpImage);

setupEncryption();

if (runArgument.runUsingMfgSecurityToken) {
  for (i = 0; i < devices.length; i++) {
    expectNoResponse(devices[i],
                   "security mfg-token set 0xCABAD11F 0");
    networkWait(2000);
    expect(devices[i], 
           "security mfg-token get",
           "  Permissions: NONE");
    networkWait(2000);
  }
}

// The aim behind this script is to do a thorough test of the Rx-On-When-Idle mechanism.

// ----------------------------------------------------------------------------
// Test 1 - touchlink from client to FN ZCR server within rx-on duration
send("remote", "plugin zll-commissioning disable");
send("sleepy-remote", "plugin zll-commissioning disable");
send("switch", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete");

// try to touchlink again while the ZR is joined - it should succeed, because
// the ZR's radio is on while it is joined, but there will be no device up,
// and no touchlink complete from the target; only from the initiator.
networkWait(5000);
send("switch", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("switch", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);

// make the target leave, then touchlink again. Note that the node id's
// differ this time, because the initiator is no longer factory new.
expect("light", "network leave", ".*EMBER_NETWORK_DOWN", timeout * 5);
send("switch", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0003 \\(\\(>\\)" + eui64("light") + "\\) complete");

// wait for the rx-on to expire, then 'cancel' the rx-on, and check that the
// light still has its receiver on, rather than off, as was the case when
// it started. (EMZIGBEE-4204)
networkWait(300000); // the default rx-on is set to 300 seconds
send("light", "plugin zll-commissioning cancel-rx-on");

// Control the light...
network.pressButton("switch", "1");
network.releaseButton("switch", "1");
expect("switch", ".*Broadcasting \"on\" command");
expect("light", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 01 payload\\[\\]");
expect("light", "Light on 0x01 is now ON");

// ...and back off.
network.pressButton("switch", "0");
network.releaseButton("switch", "0");
expect("switch", ".*Broadcasting \"off\" command");
expect("light", ".*RX len 3, ep FF, clus 0x0006 \\(On/off\\) FC 01 seq .. cmd 00 payload\\[\\]");
expect("light", "Light on 0x01 is now OFF");

// ----------------------------------------------------------------------------
// Test 2 - touchlink from client to FN SED server within rx-on-duration

// restore the rx-on status for the target, since it will have expire by now
send("sleepy-remote", "plugin zll-commissioning set-rx-on 300000");
send("light", "plugin zll-commissioning disable");
send("sleepy-remote", "plugin zll-commissioning enable");
send("switch", "plugin zll-commissioning link");
expect("sleepy-remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("sleepy-remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("sleepy-remote", timeout * 10);
expect("sleepy-remote", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0004 \\(\\(>\\)" + eui64("sleepy-remote") + "\\) complete");

// try to touchlink again while the SED is joined - it should fail, because
// the SED's radio is off while it is joined
networkWait(5000);
expect("switch", "plugin zll-commissioning link", "Touch link failed: 0x03", timeout * 10);

// make the target leave, then touchlink again. Note that the node id's
// differ this time, because the initiator is no longer factory new.
expect("sleepy-remote", "network leave", ".*EMBER_NETWORK_DOWN", timeout * 5);
send("switch", "plugin zll-commissioning link");
expect("sleepy-remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("sleepy-remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("sleepy-remote", timeout * 10);
expect("sleepy-remote", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0005 \\(\\(>\\)" + eui64("sleepy-remote") + "\\) complete");

// ----------------------------------------------------------------------------
// Test 3 - touchlink from client to server after rx-on-expiry
send("sleepy-remote", "plugin zll-commissioning disable");
expect("light", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);

// (it isn't strictly necessary to wait after a zll-comm reset, but we'll
// do it anyway in this script, to keep the output tidy in debug mode.)
networkWait(5000);

// first, we'll make the switch leave, to stop it trying to rejoin.
expect("switch", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);
networkWait(5000);

// reset the light, to make sure the radio is off, since it doesn't seem to get
// automatically switched off when it leaves.
send("light", "reset");

// reset the light's simulated encryption to 'real', otherwise it will default
// to the compile-time default of pseudo-encryption, and it won't be
// able to decrypt the rejoin request from the switch.
setupEncryption();

networkWait(300000); // the default rx-on is set to 300 seconds
expect("light", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle inactive");
expect("switch", "plugin zll-commissioning link", "Touch link failed: 0x03", timeout * 20);

// start a new rx-on period and retry the touchlink
// 10 seconds should suffice to get the light up
send("light", "plugin zll-commissioning set-rx-on 10000");  
send("switch", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete");
networkWait(50000);

// repeat for a FN SED target - the switch is still joined with the light, so
// there is no need to reset it here, or do anything to the light, apart from
// disabling touchlinking.
expect("sleepy-remote", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);
networkWait(5000);
send("light", "plugin zll-commissioning disable");
networkWait(300000); // the default rx-on is set to 300 seconds

// The simulator appears to apply a 0x3fff ms serial sleep time, regardless of long poll setting.
expect("sleepy-remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle inactive", 0x3FFF);
expect("switch", "plugin zll-commissioning link", "Touch link failed: 0x03", timeout * 10);

// start a new rx-on period and retry the touchlink
send("sleepy-remote", "plugin zll-commissioning set-rx-on 10000");  // 10 seconds should suffice
send("switch", "plugin zll-commissioning link");
expect("sleepy-remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("sleepy-remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("sleepy-remote", timeout * 10);
expect("sleepy-remote", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0003 \\(\\(>\\)" + eui64("sleepy-remote") + "\\) complete");
// }

// ----------------------------------------------------------------------------
// Test 4 - set indefinite rx-on, then touchlink
send("sleepy-remote", "plugin zll-commissioning disable");
expect("light", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);
networkWait(5000);

// we'll make the switch leave too, to stop it trying to rejoin
expect("switch", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);
networkWait(5000);

// reset the light, to make sure the radio is off, since it doesn't seem to get
// switched off when it leaves...
send("light", "reset");
setupEncryption();

send("light", "plugin zll-commissioning cancel-rx-on");
send("light", "plugin zll-commissioning set-rx-on 0xffffffff");

networkWait(500000);
expect("light", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle active");
send("switch", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete");

// repeat for a FN SED target - the switch is still joined with the light, so
// there is no need to reset it here, or do anything to the light, apart from
// disabling touchlinking.
expect("sleepy-remote", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);
networkWait(5000);
send("light", "plugin zll-commissioning disable");
send("sleepy-remote", "plugin zll-commissioning enable");

expect("sleepy-remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle active");
send("switch", "plugin zll-commissioning link");
expect("sleepy-remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("sleepy-remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("sleepy-remote", timeout * 10);
expect("sleepy-remote", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0003 \\(\\(>\\)" + eui64("sleepy-remote") + "\\) complete");

// ----------------------------------------------------------------------------
// Test 5 - set indefinite rx-on, then attempt to set a shorter duration
send("sleepy-remote", "plugin zll-commissioning disable");
expect("light", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);
networkWait(5000);

// we'll make the switch leave too, to stop it trying to rejoin
expect("switch", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);
networkWait(5000);

// reset the light, to make sure the radio is off, since it doesn't seem to get
// switched off when it leaves...
send("light", "reset");
setupEncryption();

send("light", "plugin zll-commissioning cancel-rx-on");
send("light", "plugin zll-commissioning set-rx-on 0xffffffff");

networkWait(5000);
send("light", "plugin zll-commissioning set-rx-on 10000");

// the attempt to set a shorter duration fails
networkWait(20000);
expect("light", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle active");
send("switch", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete");

// the correct way to do it is to cancel the existing rx-on first
expect("light", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);
networkWait(5000);
send("light", "reset");  // make sure the radio is off
setupEncryption();

send("light", "plugin zll-commissioning cancel-rx-on");
send("light", "plugin zll-commissioning set-rx-on 10000");
networkWait(20000);
expect("light", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle inactive");
expect("switch", "plugin zll-commissioning link", "Touch link failed: 0x03", timeout * 10);

// get the light back onto the network for the next test, so it can parent
// the joining SED
send("light", "plugin zll-commissioning cancel-rx-on");
send("light", "plugin zll-commissioning set-rx-on 0xffffffff");
expect("light", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle active");
send("switch", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0003 \\(\\(>\\)" + eui64("light") + "\\) complete");

// ----------------------------------------------------------------------------
// Test 6 - set finite rx-on, then attempt to extend and reduce
// we'll do this for a FN SED target - the switch is still joined with the light, so
// there is no need to reset it here, or do anything to the light, apart from
// disabling touchlinking.
expect("sleepy-remote", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);
networkWait(5000);
send("light", "plugin zll-commissioning disable");

// first, we'll extend the rx-on period before it expires
networkWait(100000);
send("sleepy-remote", "plugin zll-commissioning set-rx-on 250000");  // another 50 seconds
networkWait(220000);  // make sure we're in injury time

// the touchlink succeeds
expect("sleepy-remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle active");
send("switch", "plugin zll-commissioning link");
expect("sleepy-remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("sleepy-remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("sleepy-remote", timeout * 10);
expect("sleepy-remote", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0004 \\(\\(>\\)" + eui64("sleepy-remote") + "\\) complete");

// repeat, but this time we'll try to reduce the period
expect("sleepy-remote", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);
networkWait(5000);

send("sleepy-remote", "plugin zll-commissioning set-rx-on 10000");  // another 10 seconds
networkWait(20000);

// the attempt fails, since the touchlink succeeds
expect("sleepy-remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle active");
send("switch", "plugin zll-commissioning link");
expect("sleepy-remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("sleepy-remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("sleepy-remote", timeout * 10);
expect("sleepy-remote", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0005 \\(\\(>\\)" + eui64("sleepy-remote") + "\\) complete");

// the correct way to do it is to cancel the existing rx-on first
expect("sleepy-remote", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);
networkWait(5000);

send("sleepy-remote", "plugin zll-commissioning cancel-rx-on");
send("sleepy-remote", "plugin zll-commissioning set-rx-on 10000");
networkWait(20000);

// The simulator appears to apply a 0x3fff ms serial sleep time, regardless of long poll setting.
expect("sleepy-remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle inactive", 20000);
expect("switch", "plugin zll-commissioning link", "Touch link failed: 0x03", timeout * 10);

// ----------------------------------------------------------------------------
// Test 7 - touchlink from dual-mode device to a server, then touchlink from
// another client to the dual-mode device
send("light", "plugin zll-commissioning enable");
send("remote", "plugin zll-commissioning enable");
send("remote", "reset");  // ensure radio is on
setupEncryption();
networkWait(5000);
send("sleepy-remote", "plugin zll-commissioning disable");

send("remote", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("remote") + "\\) complete");
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete");

// make the dual-mode remote leave, in order to resume its rx-on mode
expect("remote", "network leave", ".*EMBER_NETWORK_DOWN", 3000);  // note, no zll reset

// switch is currently joined to its old network
expect("switch", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN", 3000);
networkWait(5000);

// we need a new network for this test
send("remote", "plugin zll-commissioning disable");
send("switch", "plugin zll-commissioning link");
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete");

// now we can touchlink the dual-mode remote
send("light", "plugin zll-commissioning disable");
send("remote", "plugin zll-commissioning enable");
send("switch", "plugin zll-commissioning link");
expect("remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0003 \\(\\(>\\)" + eui64("remote") + "\\) complete");

networkWait(50000);

// ----------------------------------------------------------------------------
// Test 8 - test the temporary rx-on behaviour for an initiator, when it tries
// to touchlink when its radio is off, for whatever reason. (We've probably
// covered most of these elsewhere, but we'll collect all the cases together
// here, because this mechanism is quite tricky to get right, and has been
// causing a certain amount of grief - see EMZIGBEE-4222, for example)

// For the factory-new cases, we just start a new rx-on period to cover the expected
// responses, so this should be reasonably straightforward.

// Note, at this point remote, switch, and light are linked (sleepy-remote is FN), so
// we will need to reset remote and switch before attempting any touchlinking.

// -------
// Case 1 - initiator is factory-new, any node type, rx-on has expired

// reset remote, and check that rx-on is active
expect("remote", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN");
expect("remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle active");

// set indefinite rx-on for target
send("light", "plugin zll-commissioning set-rx-on 0xffffffff");

// enable touchlinking on remote and light only
send("switch", "plugin zll-commissioning disable");
send("light", "plugin zll-commissioning enable");
send("sleepy-remote", "plugin zll-commissioning disable");

// wait for rx-on to expire, then touchlink light
networkWait(300000);
expect("remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle inactive");
send("remote", "plugin zll-commissioning link");

// test passes if the touchlink succeeds
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("remote") + "\\) complete");
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete");

// -------
// Case 2 - initiator is factory-new, any node type, rx-on was never started,
// because the device was initiator only

// reset switch, and check that rx-on is inactive
expect("switch", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN");
expect("switch", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle inactive");

// reset remote, to stop it rejoining
expect("remote", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN");

// enable touchlinking on switch and light only
send("remote", "plugin zll-commissioning disable");

// touchlink light
send("switch", "plugin zll-commissioning link");

// test passes if the touchlink succeeds
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("switch") + "\\) complete");
expectNetworkUp("switch", timeout * 10);
expect("switch", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete");

// For the non-factory-new case, the initiator must be a sleepy-end-device, (otherwise
// its radio will already be on) and we change the MAC idle mode directly

// -------
// Case 3 - initiator is a sleepy-end-device, and is joined, rx-on is suspended

// reset sleepy-remote, and check that rx-on is active (sleepy-remote is dual mode)
send("sleepy-remote", "plugin zll-commissioning reset");
expect("sleepy-remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle active");

// reset switch, to stop it rejoining
expect("switch", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN");

// enable touchlinking on sleepy-remote and light only
send("switch", "plugin zll-commissioning disable");

// touchlink light
send("sleepy-remote", "plugin zll-commissioning link");

// check that the first touchlink succeeds
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("sleepy-remote") + "\\) complete");
expectNetworkUp("sleepy-remote", timeout * 10);
expect("sleepy-remote", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete");

// check that rx-on is still active
expect("sleepy-remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle active");

// touchlink remote
send("remote", "plugin zll-commissioning enable");
send("light", "plugin zll-commissioning disable");
send("sleepy-remote", "plugin zll-commissioning link");

// test passes if the second touchlink succeeds
expect("remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("sleepy-remote") + "\\) complete");
expectNetworkUp("sleepy-remote", timeout * 10);
expect("sleepy-remote", "Touch link with 0x0003 \\(\\(>\\)" + eui64("remote") + "\\) complete");

// -------
// Case 4 - initiator is a sleepy-end-device, and is joined, rx-on has expired

// reset sleepy-remote, and check that rx-on is active (sleepy-remote is dual mode)
send("sleepy-remote", "plugin zll-commissioning reset");
expect("sleepy-remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle active");

// reset remote, to stop it rejoining
expect("remote", "plugin zll-commissioning reset", ".*EMBER_NETWORK_DOWN");

// enable touchlinking on sleepy-remote and light only
send("light", "plugin zll-commissioning enable");
send("remote", "plugin zll-commissioning disable");

// touchlink light
send("sleepy-remote", "plugin zll-commissioning link");

// check that the first touchlink succeeds
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("light", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("light", timeout * 10);
expect("light", "Touch link with 0x0001 \\(\\(>\\)" + eui64("sleepy-remote") + "\\) complete");
expectNetworkUp("sleepy-remote", timeout * 10);
expect("sleepy-remote", "Touch link with 0x0002 \\(\\(>\\)" + eui64("light") + "\\) complete");

// check that rx-on is still active
expect("sleepy-remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle active");

// set indefinite rx-on for target
send("remote", "plugin zll-commissioning set-rx-on 0xffffffff");

// wait for rx-on to expire (check twice for SoC, because it will have just woken
// up), then touchlink remote
networkWait(300000);
if (!runArgument.runUsingHostApps) {
  expect("sleepy-remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle active");
}
expect("sleepy-remote", "plugin zll-commissioning rx-on-active", ".*Rx-On-When-Idle inactive");
send("remote", "plugin zll-commissioning enable");
send("light", "plugin zll-commissioning disable");
send("sleepy-remote", "plugin zll-commissioning link");

// test passes if the second touchlink succeeds
expect("remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0xFFFF", timeout * 10);
expect("remote", "RX: IdentifyRequest 0x[0-9a-fA-F]{8}, 0x0000", timeout * 10);
expectNetworkUp("remote", timeout * 10);
expect("remote", "Touch link with 0xFFFF \\(\\(>\\)" + eui64("sleepy-remote") + "\\) complete");
expectNetworkUp("sleepy-remote", timeout * 10);
expect("sleepy-remote", "Touch link with 0x0003 \\(\\(>\\)" + eui64("remote") + "\\) complete");

// End of test